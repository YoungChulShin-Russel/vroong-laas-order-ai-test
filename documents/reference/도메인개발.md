# 3.1. partner 도메인 개발 (1)

## 요구사항

- 시스템에 등록된 파트너만이 상품을 등록하고 주문을 처리할 수 있다

- 파트너 등록 시 파트너명, 사업자등록번호, 이메일은 필수값이다

- 파트너는 계약이 종료되면 비활성 상태로 전환된다. 단, 파트너 정보 자체는 삭제되지 않고 유지된다

- 파트너 등록이 성공하면 등록된 이메일로 가입 완료 안내 메일을 발송한다

- 그 외 시스템을 사용하는 유저가 기본적으로 기대하는 기본 기능들 - 조회, 등록, 수정, 삭제 등의 기능을 제공해야 한다

---

## 도메인 계층 설계 및 구현 (domain package)

### Entity 구현

- 파트너라는 도메인의 용어를 정의한다
  - Partner

- 객체 관점에서 필수 속성과 메서드를 정의한다

  - 필수 속성
    - partnerName
    - businessNo
    - email

  - 필수 메서드
    - 파트너 상태 활성화
    - 파트너 상태 비활성화

- 요구사항에는 없지만 시스템의 안정적인 운영을 위해 추가적인 속성을 정의한다

  - Entity의 PK와 동등하게 사용되는 대체키를 선언한다
    - partnerToken

  - 추후 시스템 외부에 파트너 API를 오픈하여 기능을 제공할 때에는 partner의 식별자가 아니라 대체키를 사용하도록 한다

  - 하단의 **대체키에 대하여** 단락 참고

- AbstractEntity를 확장하여 사용한다

  - 데이터의 생성과 변경에 대한 정확한 일시를 남기는 것은 정말 중요하다
    - 데이터 처리와 운영, CS 대응
    - 데이터 기반의 의사 결정을 위한 지표 추출

  - Entity를 통한 데이터의 등록과 변경 과정에서 해당 일시를 남기는 반복적인 코딩을 막기 위해 JPA에서 제공하는 Auditing을 활용한다

```java
@Getter
@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public class AbstractEntity {
    
    //    @CreatedDate
    @CreationTimestamp
    private ZonedDateTime createdAt;
    
    //    @LastModifiedDate
    @UpdateTimestamp
    private ZonedDateTime updatedAt;
}
```

  - @MappedSuperclass는 JPA Entity 클래스에서 공통 매핑 정보가 필요할 때, 부모 클래스에 속성을 선언하고 상속하여 사용이 가능하게 해주는 annotation이다
    - 주문 프로젝트의 Entity 전체가 AbstractEntity를 상속하면, 데이터의 등록과 변경 시점을 표현하는 속성을 그대로 상속할 수 있다

  - @EntityListeners는 이름 그대로 JPA Entity에 특정 이벤트가 발생했을 때의 리스너과 실행 이벤트를 표현하는 annotation이다
    - 여기서는 Spring JPA가 제공하는 AuditingEntityListener를 연결하여 데이터 등록과 변경 시점을 기록하게 한다

  - @CreationTimestamp와 @UpdateTimestamp는 데이터 등록과 변경 시점을 기록하는 컬럼의 선언이다
    - 주문 프로젝트의 모든 시간 관련 컬럼은 LocalDateTime이 아니라 ZonedDateTime을 사용하기 때문에 ZonedDateTime을 지원하는 @CreationTimestamp와 @UpdateTimestamp를 사용한다
    - Spring이 제공하는 @CreatedDate와 @LastModifiedDate는 ZonedDateTime을 지원하지 않는다

  - **코드 깃헙 링크**

  - JPA Auditing을 활성화하기 위해서 아래와 같이 @EnableJpaAuditing을 추가한다

```java
@EnableJpaAuditing
@Configuration
public class JpaAuditingConfiguration {
}
```

  - **코드 깃헙 링크**

- **코드 깃헙 링크**

---

### Service 및 Implements 구현

- 해당 강의에서 제안할 도메인 로직과 Service의 역할은 다음과 같다

  - 코드를 읽으면 해당 도메인의 전체 흐름을 파악할 수 있어야 한다

  - 세세한 구현과 low level 기술은 implements (infrastructure)에 위임하고, 위임을 맡기는 구간은 interface로 정의하여 사용한다

  - Service 간에는 참조 관계를 두지 않는다

  - 하단의 **의존성 역전 원칙 (DIP)** 단락 참고

- PartnerService <Interface>에서 제공해야 하는 요구사항을 정의한다
  - 파트너 등록
  - 파트너 정보 조회
  - 파트너 활성화
  - 파트너 비활성화

- PartnerService를 정의하는 과정에서 Command와 Criteria, Info 객체의 의미를 설명하고 활용한다

  - Command와 Criteria는 Service 메서드의 처리와 조회를 위한 파라미터이다
    - Command : CUD
    - Criteria : R

  - Info는 리턴 객체이다. Database에서 조회하여 가져온 Entity를 그대로 리턴하지 않기 위한 객체이다

    - 도메인 로직의 리턴값으로 Entity를 그대로 리턴하지 않는다
      - 도메인 로직과 Entity는 프로젝트 전반에 걸쳐 사용된다. Layer 간의 참조 관계를 생각해보면 명확하다
      - 도메인 로직의 리턴 값으로 Entity를 그대로 전달한다면, domain layer 바깥에서 Entity 내의 도메인 로직이 호출되거나 Entity의 속성을 변경하는 명령어가 실행될 수도 있다
      - 이는 도메인 로직을 domain layer에 응집하고자 하는 의도에 맞지 않고, 경우에 따라서는 Entity 하위 객체의 로딩 과정에서 lazy initialization exception 등이 발생할 수도 있다

    - Info 객체는 필요에 따라 Entity의 일부 속성을 가공할 수 있다

- 구현 과정에서 네이밍에 대한 관례를 정한다
  - getXxxx : 해당 파라미터로 Entity 또는 Projection 리턴. 해당 파라미터로 조회 결과가 없다면 Exception 발생
  - findByXxxx : Optional<T> 리턴
  - makeXxxx : DB Operation과 관계없이 메모리 상에서 값을 조합하여 객체를 생성
  - initEntity : makeXxxx로 생성된 초기 Entity. DB에 저장된 객체가 아니므로 Auto Increment 기반의 PK 값이 null 임

- 파트너 Entity가 제공하는 기능과 세부적인 기술을 제공하는 implements와의 조합으로 PartnerService의 구현체를 만든다

  - Partner 도메인의 조회와 저장을 담당하는 interface를 각각 선언한다
    - PartnerReader
    - PartnerStore

  - 이제 Spring JPA를 사용하여 PartnerReader와 PartnerStore의 구현체를 만들고, 이를 infrastructure layer에 둔다
    - 도메인 로직이 low level 기술에 영향을 받지 않도록 DIP 개념을 적용한다 **(클린 소프트웨어 166P 참고)**
    - Spring JPA를 활용하여 Persistence Layer를 구현하겠지만 추후 다른 Data Access Layer 구현 기술을 사용할 수도 있다

- 이후 리펙토링을 통해 Service 로직 자체의 가독성을 높인다

  - 지속적으로 Service의 추상화 레벨을 확인한다 - 도메인 로직의 가독성을 유지하고 너무 세세한 구현이 반영되지 않도록 한다

  - 모든 비즈니스 로직의 접미사를 XxxService로 정할 필요는 없다
    - Reader, Store, Aggregator, Executor 등의 접미사를 통해 좀 더 해당 객체의 책임과 역할을 상세히 정의할 수 있다

  - Service 간에는 참조 관계를 가지지 않게 하고, 도메인의 요구사항을 한 눈에 파악할 수 있는 지속적으로 리펙토링 해나간다
    - 이렇게 하지 않으면 Service 클래스 자체가 뚱뚱해지는 경향이 있다. 도메인 흐름을 파악하기 어렵고 테스트도 어렵다
    - 기능이 추가될 때마다 생성자의 인자나 import가 과도하게 늘어나지 않도록 주의한다

  - 그 외 항목의 리펙토링을 진행한다
    - PartnerInfo.of(partner)

- @Transactional을 붙인다

  - Service에서 정의하고 구현한 메서드는 요구사항 하나 하나를 반영한다. 이 때, 데이터 정합성을 생각하면 하나의 transaction으로 묶여서 처리되어야 하는 경우가 대부분이다

  - Service에서는 Domain의 Aggregate Root와 연관된 객체를 모두 가져오고 low level 기술을 활용하여 데이터를 조회하고 저장한다

  - 이 때, 데이터 처리 및 외부 API 호출의 성공 / 실패 여부에 따라서 처리한 데이터를 전체 commit 또는 rollback을 해야할 수도 있다
    - 가령, 부모 객체는 데이터베이스 저장에 실패하고 자식 객체만 저장에 성공하면 데이터 정합성 측면에서 이슈가 된다

  - 데이터 정합성을 위해 의미있는 작업 단위마다 @Transactional을 붙여야 한다

  - readonly의 경우 성능 최적화 측면에서 선언하는 것이 좋다
    - https://vladmihalcea.com/spring-read-only-transaction-hibernate-optimization/ 참고

- **코드 깃헙 링크**

---

## 대체키에 대하여

### 식별자, PK

- DDD의 Entity 개념에서 고유한 식별자는 중요한 개념이다

- Entity는 자신의 생명주기동안 형태와 내용이 급격하게 바뀔 수도 있지만 연속성은 유지해야 한다 **(도메인 주도 설계 93p 참고)**

- 이렇게 변화하는 Entity를 추적하려면 식별성이 부여되어야 하고, 식별자는 해당 시스템 내에서 유일하고 변경되어서는 안 된다

- 보통 DBMS로 영속성을 관리하는 시스템에서의 Entity 식별자는 Table의 PK와 매핑되는 경우가 대부분이다

- MySQL의 경우 주로 AUTO_INCREMENT bigint 속성을 활용한다

### 대체키의 정의, 필요성

- 원래 대체키라는 용어 (Surrogate Key)는 자연키라는 용어와 대칭되는 개념인데, 이 강의에서는 Entity의 식별자와 동급의 의미를 가지는 추가 식별자 정도로 용어를 정의하고자 한다

- Entity의 식별자는 외부에 오픈하거나 오용되지 않도록 주의하고, 식별자가 아닌 대체키를 오픈하는 것이 여러모로 좋다

- Entity 식별자를 외부에 직접 오픈했을 때의 이슈 상황을 예시로 설명하면서, 대체키 사용의 필요성을 대신하고자 한다

- 예시 1 - 2020년 5월 특정 서비스의 실제 사례
  - BigInt(Long) 형태의 유저 아이디를 URL PATH로 사용하여 유저의 거래내역을 노출하는 GET API가 있다고 하자
  - 이런 경우, (인증 과정이 없다는 전제하에) URL의 숫자만 조작하면 다른 이의 거래내역을 손쉽게 볼 수 있게 된다
  - 이슈 발생 후 랜덤 스트링 형태의 대체키로 변환하여 API를 수정함

- 예시 2 - 외부 연동 서비스
  - 외부 협력사와 자사 서비스 간에 상품 데이터 연동 과정에서 키 값을 시스템 내부의 PK로 사용했다고 가정하자
  - 그렇게 되면 양사간의 데이터는 자사 시스템 내부의 PK로 강하게 묶이게 된다
  - 이 후 자사 시스템에서 데이터베이스를 MySQL에서 MongoDB 등으로 변경하게 된다면, 달라진 PK 체계로 인해 많은 공수가 발생할 수 있다. 외부 협력사와 추가적인 식별자 논의도 진행해야 한다

### 구현

- 시스템 내부에서의 Entity 식별자는 Long 타입의 id를 사용하고, 외부에 오픈하여 사용할 때에는 대체키를 사용한다

- 대체키는 String 기반의 token을 생성하고 unique index로 설정하여 사용한다

- 대체키를 사용할 때에는 역시 성능에 대한 고민이 많을 것인데 MySQL 기준으로 1천만 건 이상으로 넘어가기 전까지는 random string으로 사용해도 조회 성능에 크게 이슈가 없고, 성능을 고려한다면 UUID를 rearranged 하여 사용하는 것을 검토할 수 있다

- https://www.percona.com/blog/2014/12/19/store-uuid-optimized-way/ 참고

![UUID Performance Graph](그래프 이미지)

---

## 의존성 역전 원칙 (DIP)

- DIP를 간략히 정의하면 추상화 레벨이 높은 상위 수준의 모듈이 추상화 레벨이 낮은 하위 모듈에 의존하면 안된다는 것이다

- 도메인의 정책이나 업무 모델을 포함하는 것을 상위 수준의 모듈이라고 볼 수 있고, 이를 구현하기 위한 구체적인 세부 기술을 하위 모듈이라고 볼 수 있다

- 상위 수준의 모듈이 하위 수준의 모듈에 의존하는 전통적인 소프트웨어 개발 방식과 달리, 추상화된 상위 모듈에 하위 모듈이 의존하게 만드는 것이 의존성 역전 원칙 (Dependency Inversion Principle)이다

- DIP 개념으로 접근한 PartnerService와 PartnerReader, PartnerRepository를 도식화하면 다음과 같다

![DIP Diagram](다이어그램 이미지)

- PartnerReaderImpl의 실제 구현은 Spring JPA를 활용하고 있지만, 추후 Spring JDBC 또는 MyBatis 같이 다른 low level 구현을 사용하더라도 PartnerService에서는 특별한 변경 없이 사용이 가능하게 된다

- **(추가) 순수한 도메인 모델과 ORM 사용에 대한 좋은 아티클**

  - https://enterprisecraftsmanship.com/posts/having-the-domain-model-separate-from-the-persistence-model/

  - ORM을 사용하다보면 순수한 도메인 모델 (Entity)을 설계하고 구현하는 과정에서 제한을 두어야 하는 경우가 생긴다

  - 이를 극복하기 위해 별도의 DAO 클래스를 둘 수 있는데, DAO 관련 구현 비용은 비싸지 않게 유지하면서도 도메인 모듈을 순수하게 유지할 수 있다고 보여진다 → 하지만 실제로는 그렇지 않다

![Complexity vs Richness/Purity Graph](그래프 이미지)

  - DDD에서 ORM은 구현의 복잡성과 도메인의 순수성 사이에서 적절한 트레이드오프를 제공한다는 내용이다

  - 강의를 제공하는 입장에서도 Spring Data JPA는 그런 개념으로 접근해야 한다는 생각이다