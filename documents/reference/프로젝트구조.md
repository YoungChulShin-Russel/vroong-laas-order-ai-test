# 🏢 2. 프로젝트 구조 및 설계

## 좋은 구현이란

제가 생각하는 좋은 구현, 잘 짜여진 코드의 요건은 다음과 같습니다

### 비즈니스 가치를 명확히 충족시켜야 한다

- 뉴욕타임즈 CTO 의 4년 회고 - "기술조직은 회사의 비즈니스 지표에 따라 평가되어야 한다"
- 회사의 목표와 상관없이 기술적 성취에만 관심을 가지는 개발자의 가치는 얼마나 인정받을 수 있을까?
- 유저의 경험과 회사의 목표보다는 본인이 사용하게 될 기술 스택에 대한 관심만 높은 개발자가 있다면, 스스로 마인드를 바꿔야 한다고 말하고 싶다
  - 기술은 도구일 뿐이다
  - 도구에 익숙해지고 좀 더 좋은 도구를 찾는 근원적인 이유도 비즈니스 목표 달성을 위한 것이어야 한다

### 잘 읽혀야 한다

- 개발 업무를 단순히 코드 읽기와 쓰기로 분류해본다면 [읽기:쓰기] = 8:2 정도의 비중이 되지 않을까 생각한다
  - 그만큼 코드 자체의 가독성이 좋아야 업무 효율을 지속적으로 높게 유지할 수 있다
- 도메인 로직을 설명하는 별도의 문서보다는 코드 자체로 도메인을 파악할 수 있어야 한다
- 물론 시스템 전체의 아키텍쳐, 데이터 flow, 코드로 표현할 수 없는 외부 요소들 (외부 연동 회사 정보, 최적화를 위한 코드 설명 등) 은 별도의 기술문서로 표현하는 것이 맞다

### 테스트 코드 작성이 쉬워야 한다

- 테스트 코드는 지속적인 기능 런칭과 리펙토링을 가능하게 해주는 안전장치이다
- 코드간의 의존성이 많다면 그만큼 테스트 코드 작성이 어렵다
- 테스트 코드 작성이 쉬운 코드는 대체적으로 코드 품질이 좋은 편이다

### 변경에 유연해야 한다

- 요구사항은 언제든지 추가되고 바뀔 수 있다. 이는 너무도 당연한 것임을 인지해야 한다
- 그렇기 때문에 코드 구현과 설계는 요구사항 변경에 유연하도록 작성되어야 한다
- 이를 가능하게 하는 여러가지 객체지향 설계 원칙이 존재한다. 이를 잘 알고 적용하는 것이 좋다
  - 단일 책임 원칙 (SRP)
  - 개방 폐쇄 원칙 (OCP)
  - 리스코프 치환 원칙 (LSP)
  - 의존 관계 역전 원칙 (DIP)
  - 인터페이스 분리 원칙 (ISP)

## 도메인 주도 설계

마이크로 서비스 아키텍처의 컨셉을 생각하면 비즈니스 도메인 중심으로 서비스를 모델링하고 구현하는 것이 중요하다

이 때 각각의 복잡한 도메인을 모델링하고 표현력있게 설계하는 것을 도메인 주도 설계 (이하 DDD) 라고 한다

해당 강의에서는 DDD 의 개념을 개략적으로 풀어가면서 DDD 에서 권장하는 개발 방식으로 실제적인 코드 구현을 설명하고자 한다

## 강의에서 진행할 프로젝트의 Layer 구조

도메인 주도 설계에서 말하는 일반적인 엔터프라이즈 애플리케이션 레이어 구성을 참고한다 (도메인 주도 설계 72p 참고)

레이어간의 참조 관계에서는 단방향 의존을 유지하고 계층간 호출에서는 인터페이스를 통한 호출이 되도록 한다

### Layer 별 특징과 역할

| Layer | Description | (강의에서 제시하는) 주요 객체 |
|-------|-------------|--------------------------|
| 사용자 인터페이스 (interfaces) | 사용자에게 정보를 보여주고 사용자의 명령을 해석하는 책임을 진다. | Controller, Dto, Mapper (Converter) |
| 응용 계층 (application) | 수행할 작업을 정의하고 표현력 있는 도메인 객체가 문제를 해결하게 한다. 이 계층에서 책임지는 작업은 업무상 중요하거나 다른 시스템의 응용 계층과 상호 작용하는 데 필요한 것들이다. 이 계층은 얇게 유지되고, 오직 작업을 조정하고 아래에 위치한 계층에 포함된 도메인 객체의 협력자에게 작업을 위임한다. | Facade |
| 도메인 계층 (domain) | 업무 개념과 업무 상황에 대한 정보, 업무 규칙을 표현하는 일을 책임진다. 이 계층에서는 업무 상황을 반영하는 상태를 제어하고 사용하며, 그와 같은 상태 저장과 관련된 기술적인 세부사항은 인프라 스트럭쳐에 위임한다. 이 계층이 업무용 소프트웨어의 핵심이다. | Entity, Service, Command, Criteria, Info, Reader, Store, Executor, Factory (interface) |
| 인프라 스트럭쳐 계층 (infrastructure) | 상위 계층을 지원하는 일반화된 기술적 기능을 제공한다. 이러한 기능에는 애플리케이션에 대한 메시지 전송, 도메인 영속화, UI 에 위젯을 그리는 것 등이 있다. | low level 구현체 (ReaderImpl, StoreImpl, Spring JPA, RedisConnector ...) |

### Layer 간 참조 관계

- Layer 간의 참조 관계에서 application 과 Infrastructure 는 domain layer 를 바라보게 하고 양방향 참조는 허용하지 않게 한다
- domain layer 는 low level 의 기술에 상관없이 독립적으로 존재할 수 있어야 한다
- 이를 위해 대부분의 주요 로직은 추상화되고, runtime 시에는 DIP 개념을 활용하여 실제 구현체가 동작하게 한다

![Layer 구조 다이어그램]

## Layer 별 구현 상세

### Domain Layer

DDD 에서 말하는 domain layer 의 역할은 다음과 같다

- 업무 개념과 업무 상황에 대한 정보, 업무 규칙을 표현하는 일을 책임진다
- 이 계층에서는 업무 상황을 반영하는 상태를 제어하고 사용하며, 그와 같은 상태 저장과 관련된 기술적인 세부사항은 인프라 스트럭쳐에 위임한다.
- 이 계층이 업무용 소프트웨어의 핵심이다

DDD 의 목표는 기술보다는 도메인에 대한 모델에 집중해 더 나은 소프트웨어를 만들어내는 것이다 (DDD 154p 참고)

DDD 에서 도메인 모델을 정의하고 구현하는 layer 는 domain layer 이기 때문에 DDD 에서는 domain layer 가 핵심이다

강의 내에서의 domain layer 표준 구현은 다음과 같다

#### 1. domain layer 에서의 Service 에서는 해당 도메인의 전체 흐름을 파악할 수 있도록 구현되어야 한다

- 이를 위해서는 추상화 레벨을 많이 높여야 한다
  - 도메인 로직에서는 어떤 기술을 사용했는지는 중요하지 않다. 어떤 업무를 어떤 순서로 처리했는지가 더욱 중요한 관심사이다
  - 도메인 업무는 적절한 interface 를 사용하여 추상화하고 실제 구현은 다른 layer 에 맡기는게 맞다

- 세세한 기술 구현은 Service 가 아니라 Infrastructure 의 implements 클래스에 위임하고, Service 에서는 이를 활용하기 위한 interface 를 선언하고 사용한다
  - DIP 를 활용하여 도메인이 사용하는 interface 의 실제 구현체를 주입 받아 (injection) 사용할 수 있도록 한다
  - 영속화된 객체를 로딩하기 위해 Spring JPA 를 사용할 수도 있지만 MyBatis 를 사용할 수도 있는 것이다. domain layer 에서는 객체를 로딩하기 위한 추상화된 interface 를 사용하고, 실제 동작은 하위 layer 의 기술 구현체에 맡긴다는 것이 핵심이다

- 이런 식의 구현을 가져가면
  - service 의 메서드를 읽기만해도 업무 도메인의 흐름을 대략적으로 파악이 가능하고
  - interface 로 추상화된 실제 구현 기술은 언제든지 원하는 것으로 교체가 가능하게 된다

- (Spring Boot 기반의 구현이라면) 도메인을 대표하는 하나의 Service 가 존재하게 하고, 해당 Service 에는 @Service 를 붙인다
  - 해당 제안을 규약으로 가져가면, 다른 개발자들이 해당 도메인을 파악할 때 엔트리 포인트가 되는 로직을 빠르게 찾을 수 있을 것이라 기대한다

#### 2. domain layer 에서의 모든 클래스명이 XxxxService 로 선언될 필요는 없다

- 하나의 도메인 패키지 내에 수많은 Service 클래스가 존재하게 되면, 도메인 전체의 흐름을 컨트롤하는 Service 가 무엇인지 알기 어렵다
  - 주요 도메인의 흐름을 관리하는 Service 는 하나로 유지하고, 이를 위한 support 역할을 하는 클래스는 Service 이외의 네이밍을 가져가는 것이 좋다
- 또한 하나의 책임을 가져가는 각각의 구현체는 그 책임과 역할에 맞는 네이밍으로 선언하는 것이 가독성에 좋다
  - 아래와 같은 네이밍이 적절한 예시가 될 것이다
    - XxxxReader
    - XxxxStore
    - XxxxExecutor
    - XxxxFactory
    - XxxxAggregator
  - 다만 해당 구현체는 domain layer 에서는 inteface 로 추상화하고 실제 구현체는 Infrastructure layer 에서 구현한다
  - 즉, domain layer 에서는 도메인 로직의 흐름을 표현하고 구현하는 Service 와 ServiceImpl 이 있지만 그 외의 상세한 구현은 Reader, Store, Executor 같은 interface 를 선언하여 사용하고 이에 대한 실제 구현체는 Infrastructure layer 에 두고 활용한다 (DIP)

#### 3. Service 간에는 참조 관계를 가지지 않도록 한다

- DDD 의 Aggregate Root 개념을 알고 있다면 도메인 내의 Entity 간에도 상하 관계가 명확히 생긴다는 것을 알게 된다
- 이와 마찬가지로 Service 로직을 구현하다보면 좀 더 상위 레벨의 Service 와 하위 레벨의 Service 가 도출되기 마련인데, 이런 구조를 허용하게 되면 상위 레벨의 Service 가 하위 레벨의 Service 를 다수 참조하게 되면서 로직이 구성된다
  - 경험상 시간이 지날수록 특정 Service 가 참조하는 하위 Service 는 점점 늘어나는 경향이 있었다
  - 이는 테스트 코드 작성을 어렵게 하고 가독성도 많이 떨어지게 된다
- Service 간에는 참조 관계를 가지지 않도록 원칙을 세우는 것이 좋다
  - Service 내의 로직은 추상화 수준을 높게 가져가고
  - 각 추상화의 실제 구현체는 잘게 쪼개어 만들면
  - 도메인의 전체 흐름이 파악되면서도 로직이 간결하게 유지되는 코드를 가져갈 수 있다

### Infrastructure Layer

DDD 에서 말하는 Infrastructure layer 의 역할은 다음과 같다

- 상위 계층을 지원하는 일반화된 기술적 기능을 제공한다

강의 내에서의 Infrastructure layer 표준 구현은 다음과 같다

#### 1. domain layer 에 선언되고 사용되는 추상화된 interface 를 실제로 구현하여 runtime 시에는 실제 로직이 동작하게 한다

- DIP 개념을 활용한다 (예시 다이어그램)

![DIP 다이어그램]

#### 2. 세세한 기술 스택을 활용하여 domain 의 추상화된 interface 를 구현하는 것이므로 비교적 구현에서의 자유도를 높게 가져갈 수 있다

- 읽어보면 좋을만한 아티클을 공유한다
  - https://deviq.com/principles/persistence-ignorance
  - https://enterprisecraftsmanship.com/posts/having-the-domain-model-separate-from-the-persistence-model/

#### 3. Service 간의 참조 관계는 막았지만, Infrastructure layer 에서의 구현체 간에는 참조 관계를 허용한다

- Infrastructure 에서의 구현체는 domain layer 에 선언된 interface 를 구현하는 경우가 대부분이므로 Service 에 비해 의존성을 많이 가지지 않게 된다
- 로직의 재활용을 위해 Infrastructure 내의 구현체를 의존 관계로 활용해도 된다
- 다만 이 과정에서도 순환 참조가 발생하지 않도록 적절한 상하관계를 정의하는 것이 좋다 (필요시 정의)

#### 4. (Spring Boot 기반의 구현이라면) @Component 를 활용한다

- Spring 내의 동일한 bean 이라도 @Service 와 @Component 를 구분하여 선언하여 명시적인 의미를 부여하고자 한다
- 이 내용은 강의 내의 권장 표준 정도로 한다
  - Spring 에서 @Service 와 @Component 는 동일하게 class 를 bean 으로 등록하고 큰 차이는 없다
  - 다만 annotation 을 통해 해당 class 의 의미를 부여하고 싶었다

### Application Layer

도메인 주도 설계 (이하 DDD) 에서 말하는 application layer 의 역할은 다음과 같다

- 수행할 작업을 정의한다
- 도메인 객체가 문제를 해결하도록 지시한다
- 다른 애플리케이션 계층과의 상호 작용을 한다
- 비즈니스 규칙은 포함하지 않으며, 작업을 조정하고, 다음 하위 계층에서 도메인 객체의 협력을 위해 업무를 위임한다
- 그렇기 때문에 해당 Layer 는 얇게 유지된다
- 작업을 조정하기만 하고 도메인 상태를 가지면 안 된다

여기에서 가질 수 있는 의문이 있다면 다음과 같다

- 수행할 작업을 정의하고 작업을 조정하는게 결국 도메인 로직 아닌가?
- 다른 애플리케이션 계층과 상호작용을 하게되면 어쩔 수 없이 import 와 생성자 인자가 많아질 수밖에 없는 것 아닌가?

강의 내에서의 application layer 표준 구현은 다음과 같다

#### 1. application layer 에서는

- transaction 으로 묶여야 하는 도메인 로직과
- 그 외의 로직을 aggregation 하는 역할로 한정 짓는다
- 그러므로 해당 로직이 두꺼워질 요소는 없다

#### 2. 해당 layer 의 클래스 네이밍은 XxxFacade 로 정한다

- Facade 의 개념은 복잡한 여러 개의 API 를 하나의 인터페이스로 aggregation 하는 역할이지만
- 우리가 정의하는 application layer 내의 Facade 는 서비스 간의 조합으로 하나의 요구사항을 처리하는 클래스로 정의하였다

#### 3. 실제적인 요구사항을 예시로 하여 Facade 구현을 정의해보면 다음과 같다

"주문완료 후 유저에게 카카오톡으로 주문 성공 알림이 전달된다" 라는 요구사항이 있다고 해보자

- 주문 처리 과정에서의 모든 도메인 로직은 하나의 transaction 으로 묶여야 정합성에 이슈가 없다
- 그러나 주문 완료 직후의 카카오톡 알림 발송이 실패하더라도, 주문 로직이 전체 롤백될 필요는 없다
  - 카카오톡 알림 발송이 실패했더라도 유저는 메인 서비스를 통해서 주문 완료를 확인할 수 있기 때문에

이런 맥락을 기반으로 Facade 내에 주문 완료 메서드를 구현하면 다음과 같다
```java
public String completeOrder(OrderCommand.RegisterOrder registerOrder) {
    var orderToken = String = orderService.completeOrder(registerOrder);
    notificationService.sendKakao(templateId: "ORDER_COMPLETE", content: "content");
    return orderToken;
}
```
- Facade 안의 completeOrder 메서드에는 transaction 을 선언하지 않는다
- orderService.completeOrder(registerOrder) 내에는 transaction 이 선언되어 있고, 주문완료 처리 중에 예외가 발생하면 Order Aggregate 전체 데이터가 rollback 이 된다 (정합성이 지켜지는 것)
- orderService.completeOrder(registerOrder) 가 성공하고 notificationService.sendKakao() 가 실패하더라도, 주문완료 처리는 rollback 되지 않는다
- Order Aggregate 의 정합성은 지키면서도, 주요 도메인 로직에는 포함되지 않는 외부 서비스 call (여기서는 카카오톡 알림 발송) 은 성공 / 실패에 크게 민감하지 않게 요구사항을 처리하게 된다

### Interfaces Layer
DDD 에서 말하는 Interfaces layer 의 역할은 다음과 같다

- 사용자에게 정보를 보여주고 사용자의 명령을 해석하는 책임을 진다

강의 내에서의 Interfaces layer 표준 구현은 다음과 같다
1. API 를 설계할 때에는 없어도 되는 Request Parameter 는 제거하고, 외부에 리턴하는 Response 도 최소한을 유지하도록 노력하자
   - 요구하는 Request Parameter 가 많다는 것은 관련된 메서드나 객체에서 처리해야 하는 로직이 많다는 것을 의미하고, 이는 관련된 객체가 생각보다 많은 역할을 하고 있다는 신호일 수 있다
   - Response 의 경우도 불필요한 응답을 제공하고 있고 이를 가져다 쓰는 외부 로직이 있다면, 추후 해당 Response 에서 특정 프로퍼티는 제거하기 어렵게 될 수 있다
   - API 는 한번 외부에 오픈하면 바꿀 수 없는 것이라고 생각하자. 처음부터 제한적으로 설계하고 구현해야 한다

2. http, gRPC, 비동기 메시징과 같은 서비스간 통신 기술은 Interfaces layer 에서만 사용되도록 하자

   - 가령 json 처리 관련 로직이나 http cookie 파싱 로직 등이 Domain layer 에서 사용되는 식의 구현은 피해야 한다
   - 그렇게 하지 않으면 언제든지 교체될 수 있는 외부 통신 기술로 인해 domain 로직까지 변경되어야 하는 상황이 발생한다