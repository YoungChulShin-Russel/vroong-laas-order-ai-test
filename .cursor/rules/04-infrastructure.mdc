---
alwaysApply: true
---

# Infrastructure Layer 규칙

## 위치
`infrastructure/`

## 책임
- 기술 구현 (JPA, Kafka, Feign, Redis)
- Domain Port 인터페이스 구현 (Store/Reader)
- 외부 시스템 연동

## 저장소 구조

**infrastructure/**
- **storage/** - 저장소
  - **db/** - 데이터베이스 (JPA)
    - order/
      - entity/
      - adapter/
    - payment/
    - coupon/
  - **cache/** - 캐시 (Redis) [미구현]
    - order/
    - config/
- **outbox/** - Outbox Pattern
  - KafkaOutboxEventClient.java
  - KafkaOutboxEventMapper.java
  - KafkaOutboxEvent.java
- **external/** - 외부 API [미구현]
  - client/
  - adapter/
- **config/** - 공통 설정

## JPA Entity 규칙

### 반드시 해야 할 것
1. @Entity, @Table 등 JPA 어노테이션 사용
2. from(Domain) 정적 메서드로 Domain → Entity 변환
3. toDomain() 인스턴스 메서드로 Entity → Domain 변환
4. @NoArgsConstructor(access = AccessLevel.PROTECTED)
5. Getter만 사용 (Setter 금지)
6. **공통 코드 스타일 준수** (00-workflow.mdc 참고)
   - FQCN 대신 import 사용

### 절대 하지 말 것
1. Entity에 비즈니스 로직 작성 금지
2. Entity가 Domain을 상속받는 것 금지
3. FQCN(Fully Qualified Class Name) 사용 금지
4. EAGER fetch 사용 금지
5. 양방향 연관관계 최소화

### JPA Entity 템플릿

```java
// infrastructure/storage/db/order/entity/OrderJpaEntity.java
@Entity
@Table(name = "orders")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class OrderJpaEntity {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private Long userId;
    
    @Column(nullable = false, unique = true)
    private String orderNumber;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private OrderStatus status;
    
    @Column(nullable = false)
    private BigDecimal totalAmount;
    
    @Embedded
    private AddressEmbed deliveryAddress;
    
    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
    @JoinColumn(name = "order_id")
    private List<OrderItemJpaEntity> items = new ArrayList<>();
    
    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    // Domain → Entity 변환
    public static OrderJpaEntity from(Order domain) {
        OrderJpaEntity entity = new OrderJpaEntity();
        entity.id = domain.getId();
        entity.userId = domain.getUserId();
        entity.orderNumber = domain.getOrderNumber();
        entity.status = domain.getStatus();
        entity.totalAmount = domain.getTotalAmount().value();
        entity.deliveryAddress = AddressEmbed.from(domain.getDeliveryAddress());
        entity.items = domain.getItems().stream()
            .map(OrderItemJpaEntity::from)
            .collect(Collectors.toList());
        entity.createdAt = domain.getCreatedAt();
        return entity;
    }
    
    // Entity → Domain 변환
    public Order toDomain() {
        return Order.builder()
            .id(this.id)
            .userId(this.userId)
            .orderNumber(this.orderNumber)
            .status(this.status)
            .totalAmount(Money.of(this.totalAmount))
            .deliveryAddress(this.deliveryAddress.toDomain())
            .items(this.items.stream()
                .map(OrderItemJpaEntity::toDomain)
                .collect(Collectors.toList()))
            .createdAt(this.createdAt)
            .build();
    }
}
```

```java
// infrastructure/storage/db/order/entity/OrderItemJpaEntity.java
@Entity
@Table(name = "order_items")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class OrderItemJpaEntity {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private Long productId;
    
    @Column(nullable = false)
    private String productName;
    
    @Column(nullable = false)
    private Integer quantity;
    
    @Column(nullable = false)
    private BigDecimal unitPrice;
    
    public static OrderItemJpaEntity from(OrderItem domain) {
        OrderItemJpaEntity entity = new OrderItemJpaEntity();
        entity.id = domain.getId();
        entity.productId = domain.getProductId();
        entity.productName = domain.getProductName();
        entity.quantity = domain.getQuantity();
        entity.unitPrice = domain.getUnitPrice().value();
        return entity;
    }
    
    public OrderItem toDomain() {
        return OrderItem.builder()
            .id(this.id)
            .productId(this.productId)
            .productName(this.productName)
            .quantity(this.quantity)
            .unitPrice(Money.of(this.unitPrice))
            .build();
    }
}
```

```java
// infrastructure/storage/db/order/entity/AddressEmbed.java
@Embeddable
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AllArgsConstructor
public class AddressEmbed {
    
    @Column(name = "zip_code", nullable = false)
    private String zipCode;
    
    @Column(name = "street", nullable = false)
    private String street;
    
    @Column(name = "detail")
    private String detail;
    
    public static AddressEmbed from(Address domain) {
        return new AddressEmbed(
            domain.zipCode(),
            domain.street(),
            domain.detail()
        );
    }
    
    public Address toDomain() {
        return new Address(zipCode, street, detail);
    }
}
```

---

## Flyway 마이그레이션 규칙 ⭐

### 위치
`infrastructure/src/main/resources/db/migration/`

### 필수 원칙
**Domain Entity나 JPA Entity가 변경되면 반드시 Flyway 마이그레이션 파일을 추가해야 합니다.**

### 파일 네이밍 규칙

```
V{YYYYMMDD}_{NNN}__{Description}.sql
```

**예시:**
```
V20250106_001__Create_order_aggregate.sql
V20250107_001__Add_order_memo_column.sql
V20250107_002__Add_index_on_order_number.sql
```

**구성:**
- **V**: Version prefix (필수, 대문자)
- **YYYYMMDD**: 날짜 (8자리)
- **NNN**: 일련번호 (3자리, 001부터)
- **__**: 구분자 (언더스코어 2개)
- **Description**: 영문 설명 (Snake_case)

### Entity 변경 시 워크플로우

#### 1. Domain Entity 변경
```java
// core/domain/order/Order.java
@Getter
@Builder
public class Order {
    private String memo;  // ⭐ 새 필드 추가
}
```

#### 2. JPA Entity 변경
```java
// infrastructure/storage/db/order/entity/OrderJpaEntity.java
@Column(name = "memo")
private String memo;  // ⭐ 새 컬럼 추가
```

#### 3. Flyway 마이그레이션 파일 생성 (필수!)
```sql
-- infrastructure/src/main/resources/db/migration/V20250107_001__Add_order_memo_column.sql
ALTER TABLE orders 
ADD COLUMN memo VARCHAR(1000) NULL COMMENT '주문 메모';
```

#### 4. 로컬 테스트
```bash
# 1. 애플리케이션 실행 (Flyway 자동 실행)
./gradlew :api:bootRun

# 2. 테이블 확인
docker exec order-mysql mysql -u order_user -porder_password order -e "DESC orders;"

# 3. Flyway 이력 확인
docker exec order-mysql mysql -u order_user -porder_password order \
  -e "SELECT * FROM flyway_schema_history;"
```

### 변경 타입별 파일명

| 변경 타입 | 파일명 형식 | 예시 |
|----------|-----------|------|
| Aggregate 생성 | `V{YYYYMMDD}_001__Create_{aggregate}_aggregate.sql` | `V20250106_001__Create_order_aggregate.sql` |
| 컬럼 추가 | `V{YYYYMMDD}_{NNN}__Add_{table}_{column}_column.sql` | `V20250107_001__Add_order_memo_column.sql` |
| 컬럼 변경 | `V{YYYYMMDD}_{NNN}__Alter_{table}_{column}.sql` | `V20250107_002__Alter_order_memo_increase_length.sql` |
| 인덱스 추가 | `V{YYYYMMDD}_{NNN}__Add_index_on_{table}_{column}.sql` | `V20250107_003__Add_index_on_order_number.sql` |
| 테이블 삭제 | `V{YYYYMMDD}_{NNN}__Drop_{table}_table.sql` | `V20250107_004__Drop_old_order_history_table.sql` |

### 체크리스트

Entity 변경 시 다음을 반드시 확인:

- [ ] Domain Entity가 변경되었는가?
- [ ] JPA Entity가 변경되었는가?
- [ ] **Flyway 마이그레이션 파일을 생성했는가?** ⭐
- [ ] 파일명이 네이밍 규칙을 따르는가?
- [ ] 로컬에서 테스트했는가?
- [ ] 테이블 변경사항이 정확한가?
- [ ] 롤백 스크립트를 문서화했는가?

### 절대 하지 말 것

❌ **이미 적용된 마이그레이션 파일 수정 금지**
```sql
-- V20250106_001__Create_order_aggregate.sql (이미 적용됨)
-- 이 파일을 수정하지 마세요! 새로운 마이그레이션 파일을 만드세요.
```

❌ **같은 날짜에 일련번호 중복 금지**
```
V20250107_001__Add_column_A.sql
V20250107_001__Add_column_B.sql  // ❌ 일련번호 중복!
```

❌ **JPA `ddl-auto`에 의존 금지**
```yaml
# application.yml
spring:
  jpa:
    hibernate:
      ddl-auto: none  # 반드시 none! (Flyway가 관리)
```

### 반드시 해야 할 것

✅ **롤백 스크립트 준비**
```sql
-- V20250107_001__Add_order_memo_column.sql
ALTER TABLE orders ADD COLUMN memo VARCHAR(1000) NULL;

-- 롤백 스크립트 (별도 문서화)
-- ALTER TABLE orders DROP COLUMN memo;
```

✅ **Production 적용 전 Staging 테스트**

✅ **대용량 테이블 변경 시 점검 시간 확보**

### FlywayConfig 설정

```java
// infrastructure/common/config/FlywayConfig.java
@Configuration
@Profile("local")  // Local 환경에서만 실행
class FlywayConfig {
    
    @Bean(initMethod = "migrate")
    public Flyway flyway(DataSource dataSource) {
        return Flyway.configure()
            .dataSource(dataSource)
            .locations("classpath:db/migration")
            .baselineOnMigrate(true)
            .baselineVersion("0")
            .validateOnMigrate(true)
            .outOfOrder(false)
            .cleanDisabled(true)
            .load();
    }
}
```

### 환경별 실행 전략

**Local 환경:**
- Flyway가 자동으로 마이그레이션 실행
- `@Profile("local")` 활성화

**Production 환경:**
- DBA가 수동으로 SQL 스크립트 실행
- Flyway 비활성화

### 자세한 가이드

**더 상세한 마이그레이션 가이드는 [documents/flyway-guide.md](../documents/flyway-guide.md)를 참고하세요.**

---

## Repository Adapter 규칙

### 위치
`infrastructure/storage/db/*/adapter/`

### 책임
- OrderRepository 인터페이스 구현 (통합)
- JpaRepository 사용
- Domain ↔ Entity 변환
- **@Transactional 관리 (트랜잭션 경계)**

### Repository Adapter 템플릿

```java
// infrastructure/storage/db/order/adapter/OrderRepositoryAdapter.java
@Repository
@RequiredArgsConstructor
public class OrderRepositoryAdapter implements OrderRepository {
    
    private final OrderJpaRepository orderJpaRepository;
    private final OrderItemJpaRepository orderItemJpaRepository;
    private final OrderLocationJpaRepository orderLocationJpaRepository;
    private final OrderDeliveryPolicyJpaRepository orderDeliveryPolicyJpaRepository;
    
    /**
     * Order 생성 및 저장
     *
     * <p>Order Entity를 생성하고 저장한 후, Order.create()로 완전한 Domain Model 반환
     */
    @Transactional  // ⭐ 여기서 트랜잭션 관리
    @Override
    public Order store(
        OrderNumber orderNumber,
        List<OrderItem> items,
        Origin origin,
        Destination destination,
        DeliveryPolicy deliveryPolicy) {

      // 1. OrderEntity 생성 및 저장
      OrderEntity orderEntity =
          OrderEntity.builder()
              .orderNumber(orderNumber.value())
              .status(OrderStatus.CREATED)
              .orderedAt(Instant.now())
              .build();
      OrderEntity savedOrderEntity = orderJpaRepository.save(orderEntity);
      Long orderId = savedOrderEntity.getId();

      // 2. 연관 Entity 저장
      saveOrderItems(items, orderId);
      saveOrderLocation(origin, destination, orderId);
      saveOrderDeliveryPolicy(deliveryPolicy, orderId);

      // 3. Order.create()로 완전한 Domain Model 생성 (Domain Event 자동 추가)
      return Order.create(orderId, orderNumber, items, origin, destination, deliveryPolicy);
    }
    
    @Transactional(readOnly = true)
    @Override
    public Optional<Order> findById(Long id) {
        return orderJpaRepository.findById(id)
            .map(entity -> reconstructOrder(entity));
    }
    
    @Transactional(readOnly = true)
    @Override
    public Optional<Order> findByOrderNumber(OrderNumber orderNumber) {
        return orderJpaRepository.findByOrderNumber(orderNumber.value())
            .map(entity -> reconstructOrder(entity));
    }
    
    @Override
    public boolean existsByOrderNumber(OrderNumber orderNumber) {
        return orderJpaRepository.existsByOrderNumber(orderNumber.value());
    }
    
    // private 헬퍼 메서드들
    private void saveOrderItems(List<OrderItem> items, Long orderId) { /* ... */ }
    private void saveOrderLocation(Origin origin, Destination destination, Long orderId) { /* ... */ }
    private void saveOrderDeliveryPolicy(DeliveryPolicy deliveryPolicy, Long orderId) { /* ... */ }
    private Order reconstructOrder(OrderEntity entity) { /* ... */ }
}
```

**특징:**
- ✅ **Store/Reader 통합** (하나의 Repository)
- ✅ `store()` 메서드가 Order Entity 생성 및 저장
- ✅ `Order.create()`로 Domain Model 생성 (Domain Event 자동 추가)
- ✅ 메서드 단위로 짧은 트랜잭션
- ✅ Domain Service에서 @Transactional로 트랜잭션 관리

```java
// infrastructure/storage/db/order/adapter/OrderJpaRepository.java
public interface OrderJpaRepository extends JpaRepository<OrderEntity, Long> {
    
    Optional<OrderEntity> findByOrderNumber(String orderNumber);
    boolean existsByOrderNumber(String orderNumber);
}
```

---

## 부분 업데이트 패턴 (Partial Update) ⭐

도메인의 특정 필드만 업데이트하는 패턴입니다.

**사용 시기:**
- ✅ 전체 Aggregate를 교체하지 않고 일부 필드만 변경
- ✅ 성능 최적화 (불필요한 필드 업데이트 방지)
- ✅ 명확한 업데이트 의도 표현

### 예시: 주문 도착지 주소 업데이트

**1. Repository Port (Domain Layer)**

```java
// core/domain/order/required/OrderRepository.java
public interface OrderRepository {
    
    /**
     * 도착지 주소 업데이트
     *
     * <p>변경 범위:
     * - Address (주소)
     * - LatLng (위경도)
     * - EntranceInfo (출입 가이드)
     *
     * <p>유지되는 것:
     * - Contact (연락처) - 변경되지 않음
     */
    void updateDestinationAddress(
        Long orderId, 
        Address newAddress, 
        LatLng newLatLng, 
        EntranceInfo newEntranceInfo
    );
}
```

**2. Repository Adapter (Infrastructure Layer)**

```java
// infrastructure/storage/db/order/adapter/OrderRepositoryAdapter.java
@Override
public void updateDestinationAddress(
    Long orderId, Address newAddress, LatLng newLatLng, EntranceInfo newEntranceInfo) {
    
    // 1. Entity 조회
    OrderLocationEntity locationEntity = orderLocationJpaRepository
        .findByOrderId(orderId)
        .orElseThrow(() -> 
            new IllegalStateException("OrderLocation이 없습니다. orderId: " + orderId));
    
    // 2. Entity의 업데이트 메서드 호출
    locationEntity.updateDestinationAddress(newAddress, newLatLng, newEntranceInfo);
    
    // 3. 명시적 save 호출 (의도 명확)
    orderLocationJpaRepository.save(locationEntity);
}
```

**3. Entity 업데이트 메서드 (Infrastructure Layer)**

```java
// infrastructure/storage/db/order/OrderLocationEntity.java
@Entity
@Table(name = "order_locations")
public class OrderLocationEntity extends BaseEntity {
    
    // Contact 필드 (변경되지 않음)
    @Column(name = "destination_contact_name")
    private String destinationContactName;
    
    @Column(name = "destination_contact_phone_number")
    private String destinationContactPhoneNumber;
    
    // Address 필드
    @Column(name = "destination_jibnun_address")
    private String destinationJibnunAddress;
    
    @Column(name = "destination_road_address")
    private String destinationRoadAddress;
    
    @Column(name = "destination_detail_address")
    private String destinationDetailAddress;
    
    // LatLng 필드
    @Column(name = "destination_latitude")
    private BigDecimal destinationLatitude;
    
    @Column(name = "destination_longitude")
    private BigDecimal destinationLongitude;
    
    // EntranceInfo 필드
    @Column(name = "destination_entrance_password")
    private String destinationEntrancePassword;
    
    @Column(name = "destination_entrance_guide")
    private String destinationEntranceGuide;
    
    @Column(name = "destination_request_message")
    private String destinationRequestMessage;
    
    /**
     * Destination 주소 정보만 업데이트
     *
     * <p>변경 범위:
     * - Address (주소)
     * - LatLng (위경도)
     * - EntranceInfo (출입 가이드)
     *
     * <p>유지되는 것:
     * - Contact (연락처) - 변경되지 않음
     */
    public void updateDestinationAddress(
        Address newAddress, LatLng newLatLng, EntranceInfo newEntranceInfo) {
        
        // Contact는 유지 (destinationContactName, destinationContactPhoneNumber 변경 안 함)
        
        // Address 업데이트
        this.destinationJibnunAddress = newAddress.jibnunAddress();
        this.destinationRoadAddress = newAddress.roadAddress();
        this.destinationDetailAddress = newAddress.detailAddress();
        
        // LatLng 업데이트
        this.destinationLatitude = newLatLng.latitude();
        this.destinationLongitude = newLatLng.longitude();
        
        // EntranceInfo 업데이트
        this.destinationEntrancePassword = newEntranceInfo.password();
        this.destinationEntranceGuide = newEntranceInfo.guide();
        this.destinationRequestMessage = newEntranceInfo.requestMessage();
    }
}
```

**4. Domain Service에서 사용 (Domain Layer)**

```java
// core/domain/order/OrderLocationChanger.java
@Service
@RequiredArgsConstructor
public class OrderLocationChanger {
    
    private final OrderRepository orderRepository;
    
    @Transactional  // ⭐ 트랜잭션은 Domain Service에서 관리
    public Order changeDestinationAddress(
        Order order,
        Address refinedAddress,
        LatLng refinedLatLng,
        EntranceInfo refinedEntranceInfo) {
        
        // 1. 도착지 주소 변경 (도메인 이벤트 추가)
        order.changeDestinationAddress(refinedAddress, refinedLatLng, refinedEntranceInfo);
        
        // 2. DB 업데이트 (부분 업데이트)
        orderRepository.updateDestinationAddress(
            order.getId(), refinedAddress, refinedLatLng, refinedEntranceInfo);
        
        return order;
    }
}
```

### 특징

**장점:**
- ✅ 특정 필드만 업데이트 (효율적)
- ✅ 명시적 save() 호출 (의도 명확)
- ✅ Entity의 업데이트 메서드로 캡슐화
- ✅ 트랜잭션은 Domain Service에서 관리
- ✅ 불필요한 데이터 변경 방지

**주의사항:**
- ⚠️ @Version을 사용한 낙관적 락 권장 (동시성 제어)
- ⚠️ save() 호출 필수 (JPA Dirty Checking에만 의존하지 말 것)
- ⚠️ Entity 업데이트 메서드는 단순 필드 변경만 (비즈니스 로직 금지)

**vs 전체 교체:**

| 패턴 | 용도 | 성능 | 명확성 |
|---|---|---|---|
| **부분 업데이트** | 특정 필드만 변경 | ✅ 효율적 | ✅ 명확 |
| **전체 교체** | Aggregate 전체 교체 | ⚠️ 모든 필드 변경 | ⚠️ 의도 불명확 |

---

## Outbox Pattern 구현

### 위치
`infrastructure/outbox/`

### 책임
- OutboxEventClient Port 구현
- Domain Model → Kafka Event Payload 변환
- Outbox 라이브러리 호출

### Outbox 흐름

```
OrderCreator (Domain Service)
  1. orderRepository.store(order)        → Order 저장 (DB)
  2. outboxEventAppender.append(order)   → Outbox 저장 (DB, 같은 트랜잭션)
     → outboxEventClient.save()          → Infrastructure Layer
       → KafkaOutboxEventMapper.map()    → Order → KafkaEvent 변환
       → outboxEventService.registerEvent() → Outbox 라이브러리 호출
```

### KafkaOutboxEventClient (Adapter)

```java
// infrastructure/outbox/KafkaOutboxEventClient.java
@Repository
@RequiredArgsConstructor
@Slf4j
public class KafkaOutboxEventClient implements OutboxEventClient {

  private final OutboxEventService outboxEventService;
  private final KafkaOutboxEventMapper outboxEventMapper = new KafkaOutboxEventMapper();

  /**
   * Domain Event를 Outbox에 저장
   */
  @Override
  public void save(OutboxEventType eventType, AggregateRoot aggregateRoot) {
    KafkaOutboxEvent event = outboxEventMapper.map(eventType, aggregateRoot);
    outboxEventService.registerEvent(event.kafkaEvent(), event.eventKey());
  }
}
```

### KafkaOutboxEventMapper

```java
// infrastructure/outbox/KafkaOutboxEventMapper.java
class KafkaOutboxEventMapper {

  private final KafkaEventSource ORDER_EVENT_SOURCE = KafkaEventSource.ORDER;

  public KafkaOutboxEvent map(OutboxEventType eventType, AggregateRoot aggregateRoot) {
    if (eventType == OutboxEventType.ORDER_CREATED) {
      Order order = (Order) aggregateRoot;
      return mapToOrderCreatedEvent(order);
    }

    throw new IllegalArgumentException("지원하지 않는 이벤트 타입입니다: " + eventType);
  }

  private KafkaOutboxEvent mapToOrderCreatedEvent(Order order) {
    // 1. Items 매핑
    List<OrderCreatedOrderItem> items = order.getItems().stream()
        .map(item -> OrderCreatedOrderItem.builder()
            .itemName(item.itemName())
            .quantity(item.quantity())
            .price(item.price().amount())
            .category(item.category())
            .weight(item.weight() != null ? item.weight().value() : null)
            .build())
        .toList();

    // 2. Origin/Destination 매핑
    OrderCreatedOrderLocation originLocation = mapToLocation(order.getOrigin());
    OrderCreatedOrderLocation destinationLocation = mapToLocation(order.getDestination());

    // 3. Delivery Policy 매핑
    OrderCreatedOrderDeliveryPolicy deliveryPolicy = mapToDeliveryPolicy(order.getDeliveryPolicy());

    // 4. Payload 생성
    OrderCreatedKafkaEventPayload payload = OrderCreatedKafkaEventPayload.builder()
        .orderId(order.getId())
        .orderNumber(order.getOrderNumber().value())
        .orderStatus(order.getStatus().name())
        .items(items)
        .originLocation(originLocation)
        .destinationLocation(destinationLocation)
        .deliveryPolicy(deliveryPolicy)
        .orderedAt(order.getOrderedAt())
        .build();

    // 5. KafkaEvent 생성
    KafkaEvent<KafkaEventPayload> kafkaEvent = KafkaEvent.of(
        KafkaEventType.ORDER_ORDER_CREATED,
        ORDER_EVENT_SOURCE,
        payload);

    // 6. KafkaOutboxEvent 반환
    return new KafkaOutboxEvent(String.valueOf(order.getId()), kafkaEvent);
  }

  // 헬퍼 메서드들
  private OrderCreatedOrderLocation mapToLocation(Origin origin) { /* ... */ }
  private OrderCreatedOrderDeliveryPolicy mapToDeliveryPolicy(DeliveryPolicy policy) { /* ... */ }
}
```

### KafkaOutboxEvent (DTO)

```java
// infrastructure/outbox/KafkaOutboxEvent.java
record KafkaOutboxEvent(
    String eventKey,
    KafkaEvent<KafkaEventPayload> kafkaEvent
) { }
```

**특징:**
- ✅ DB 트랜잭션과 이벤트 발행의 원자성 보장
- ✅ Order 저장 + Outbox 저장 = 하나의 트랜잭션
- ✅ 별도 Worker가 Outbox → Kafka 전송 (비동기)
- ✅ 메시지 전송 실패 시 재시도 보장

## 외부 API Adapter 규칙

### 위치
`infrastructure/external/`

### 책임
- 외부 시스템 연동
- Application Port 구현
- Feign Client 사용

### 외부 API Adapter 템플릿

```java
// infrastructure/external/client/PaymentFeignClient.java
@FeignClient(name = "payment-service", url = "${payment.service.url}")
public interface PaymentFeignClient {
    
    @PostMapping("/api/v1/payments")
    PaymentApiResponse processPayment(@RequestBody PaymentApiRequest request);
    
    @PostMapping("/api/v1/payments/{paymentId}/cancel")
    void cancelPayment(@PathVariable Long paymentId);
    
    @PostMapping("/api/v1/payments/{paymentId}/refund")
    void refundPayment(
        @PathVariable Long paymentId,
        @RequestBody RefundApiRequest request
    );
}
```

```java
// infrastructure/external/adapter/PaymentAdapter.java
@Component
@RequiredArgsConstructor
public class PaymentAdapter implements PaymentPort {
    
    private final PaymentFeignClient paymentClient;
    
    @Override
    public Payment processPayment(Long orderId, Money amount, PaymentMethod method) {
        PaymentApiRequest request = PaymentApiRequest.builder()
            .orderId(orderId)
            .amount(amount.value())
            .method(method.name())
            .build();
        
        try {
            PaymentApiResponse response = paymentClient.processPayment(request);
            
            return Payment.builder()
                .id(response.paymentId())
                .orderId(orderId)
                .amount(Money.of(response.amount()))
                .method(method)
                .status(PaymentStatus.valueOf(response.status()))
                .build();
                
        } catch (FeignException e) {
            throw new PaymentProcessingException("결제 처리 실패", e);
        }
    }
    
    @Override
    public void cancelPayment(Long paymentId) {
        try {
            paymentClient.cancelPayment(paymentId);
        } catch (FeignException e) {
            throw new PaymentCancellationException("결제 취소 실패", e);
        }
    }
}
```

## Kafka Event Publisher 규칙

### 위치
`infrastructure/messaging/adapter/`

### Kafka Event Publisher 템플릿

```java
// infrastructure/messaging/adapter/KafkaEventPublisher.java
@Component
@RequiredArgsConstructor
public class KafkaEventPublisher implements EventPublisher {
    
    private final KafkaTemplate<String, Object> kafkaTemplate;
    
    @Override
    public void publish(DomainEvent event) {
        String topic = resolveTopicName(event);
        String key = event.getAggregateId().toString();
        
        kafkaTemplate.send(topic, key, event)
            .whenComplete((result, ex) -> {
                if (ex != null) {
                    log.error("Failed to publish event: {}", event, ex);
                } else {
                    log.info("Event published successfully: {}", event);
                }
            });
    }
    
    private String resolveTopicName(DomainEvent event) {
        return switch (event) {
            case OrderCreatedEvent e -> "order.created";
            case OrderCancelledEvent e -> "order.cancelled";
            case OrderStatusChangedEvent e -> "order.status-changed";
            default -> throw new IllegalArgumentException("Unknown event type");
        };
    }
}
```

```java
// infrastructure/messaging/adapter/OrderEventConsumer.java
@Component
@RequiredArgsConstructor
public class OrderEventConsumer {
    
    private final OrderStore orderStore;
    
    @KafkaListener(topics = "inventory.reserved", groupId = "order-service")
    public void handleInventoryReserved(InventoryReservedEvent event) {
        Order order = orderStore.findById(event.orderId())
            .orElseThrow();
        
        order.confirmInventoryReserved();
        orderStore.save(order);
    }
    
    @KafkaListener(topics = "payment.completed", groupId = "order-service")
    public void handlePaymentCompleted(PaymentCompletedEvent event) {
        Order order = orderStore.findById(event.orderId())
            .orElseThrow();
        
        order.completePayment(event.paymentId());
        orderStore.save(order);
    }
}
```

## Cache Adapter 규칙

### 위치
`infrastructure/storage/cache/`

### Cache Adapter 템플릿

```java
// infrastructure/storage/cache/order/OrderCacheAdapter.java
@Component
@RequiredArgsConstructor
public class OrderCacheAdapter {
    
    private final RedisTemplate<String, OrderCacheDto> redisTemplate;
    
    private static final String CACHE_KEY_PREFIX = "order:";
    private static final Duration CACHE_TTL = Duration.ofMinutes(10);
    
    public Optional<Order> findById(Long orderId) {
        String key = CACHE_KEY_PREFIX + orderId;
        OrderCacheDto cached = redisTemplate.opsForValue().get(key);
        
        return Optional.ofNullable(cached)
            .map(OrderCacheDto::toDomain);
    }
    
    public void save(Order order) {
        String key = CACHE_KEY_PREFIX + order.getId();
        OrderCacheDto dto = OrderCacheDto.from(order);
        redisTemplate.opsForValue().set(key, dto, CACHE_TTL);
    }
    
    public void evict(Long orderId) {
        String key = CACHE_KEY_PREFIX + orderId;
        redisTemplate.delete(key);
    }
}
```

## 설정 파일

### JPA Config

```java
// infrastructure/config/JpaConfig.java
@Configuration
@EnableJpaAuditing
@EnableJpaRepositories(basePackages = "vroong.laas.order.infrastructure.storage.db")
public class JpaConfig {
}
```

### QueryDSL Config

```java
// infrastructure/config/QueryDslConfig.java
@Configuration
public class QueryDslConfig {
    
    @Bean
    public JPAQueryFactory jpaQueryFactory(EntityManager entityManager) {
        return new JPAQueryFactory(entityManager);
    }
}
```

### Feign Config

```java
// infrastructure/config/FeignConfig.java
@Configuration
public class FeignConfig {
    
    @Bean
    public Logger.Level feignLoggerLevel() {
        return Logger.Level.FULL;
    }
    
    @Bean
    public ErrorDecoder errorDecoder() {
        return new CustomErrorDecoder();
    }
}
```

## 절대 금지 사항
1. Entity에 비즈니스 로직 작성 금지
2. EAGER fetch 사용 금지
3. Entity가 Domain을 상속하는 것 금지
4. Adapter에서 직접 Domain 로직 실행 금지
5. 양방향 연관관계 남발 금지

## 중요 원칙
1. Entity는 단순 데이터 구조체
2. from/toDomain으로 명확한 변환
3. Adapter는 인터페이스 구현만
4. QueryDSL로 동적 쿼리
5. 외부 API 오류는 Domain 예외로 변환