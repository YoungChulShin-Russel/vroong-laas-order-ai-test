---
alwaysApply: true
---

# Job Layer 규칙

## 위치
`job/`

## 저장소 구조

```
job/
├── src/main/java/vroong/laas/order/job/
│   ├── JobApplication.java          # Main Application
│   ├── common/
│   │   ├── aspect/
│   │   │   └── ScheduledJobLoggingAspect.java  # AOP (로깅, 예외처리)
│   │   └── config/
│   │       ├── SchedulingConfig.java        # Thread Pool 설정
│   │       ├── SchedulingProperties.java    # Thread Pool 설정 Properties
│   │       └── *Properties.java             # 기타 설정 클래스
│   ├── scheduled/
│   │   └── BaseScheduledJob.java    # 기본 인터페이스
│   └── outbox/                       # ⭐ 기능별 패키지
│       └── OutboxEventPublishJob.java     # Outbox Event Publish Job
└── src/main/resources/
    └── application.yml
```

## 책임
- Scheduled Job 실행
- Outbox Polling (Outbox → Kafka 전송)
- 주기적인 통계 집계
- 데이터 정리 작업

---

## 필수 규칙 ⭐

### 1. BaseScheduledJob 구현

**모든 Scheduled Job은 BaseScheduledJob 인터페이스를 구현해야 합니다.**

#### ✅ 올바른 예

```java
@Component
@RequiredArgsConstructor
@Slf4j
public class OutboxEventPublishJob implements BaseScheduledJob {
    
    private final OutboxEventService outboxEventService;
    private final OutboxEventPublishProperties properties;
    
    @Scheduled(fixedDelay = 10000)
    @Override
    public void execute() {
        // 비즈니스 로직
        int count = outboxEventService.publishPendingEvents(properties.getBatchSize());
        
        if (count > 0) {
            log.info("Published {} events from outbox to Kafka", count);
        }
    }
}
```

**AOP가 자동으로 제공하는 기능:**
- ✅ 실행 시작/종료 로깅 (`[JobName] Job started/completed`)
- ✅ 실행 시간 자동 측정
- ✅ 예외 자동 처리 (다음 실행 보장)
- ✅ 일관된 로깅 포맷

**로그 출력 예시:**
```
2025-01-12 10:00:00.123 DEBUG [OutboxEventPublishJob] Job started
2025-01-12 10:00:00.456 INFO  Published 3 events from outbox to Kafka
2025-01-12 10:00:00.789 INFO  [OutboxEventPublishJob] Job completed successfully in 666ms
```

---

### 2. 1개 클래스 = 1개 작업

**한 클래스에는 하나의 @Scheduled 메서드만 존재해야 합니다.**

#### ❌ 나쁜 예 - 여러 작업을 한 클래스에

```java
@Component
public class OrderJob implements BaseScheduledJob {
    
    @Scheduled(fixedDelay = 10000)
    @Override
    public void execute() {
        pollOutbox();
    }
    
    @Scheduled(cron = "0 0 1 * * *")  // ❌ 금지! 다른 작업
    public void calculateStatistics() {
        // ...
    }
}
```

#### ✅ 좋은 예 - 작업별로 클래스 분리

```java
// OutboxEventPublishJob.java
@Component
public class OutboxEventPublishJob implements BaseScheduledJob {
    
    @Scheduled(fixedDelay = 10000)
    @Override
    public void execute() {
        // Outbox Polling 로직
    }
}

// OrderStatisticsJob.java
@Component
public class OrderStatisticsJob implements BaseScheduledJob {
    
    @Scheduled(cron = "0 0 1 * * *")
    @Override
    public void execute() {
        // 통계 집계 로직
    }
}
```

**이유:**
- ✅ 단일 책임 원칙 (SRP)
- ✅ 테스트 용이
- ✅ 독립적인 활성화/비활성화 가능
- ✅ 독립적인 실행 주기 관리

---

### 3. 클래스 이름은 *Job으로 끝나야 함

**모든 Scheduled Job 클래스는 "Job" 접미사로 끝나야 합니다.**

#### ✅ 올바른 이름

```java
OutboxEventPublishJob
OrderStatisticsJob
DataCleanupJob
OrderNotificationJob
```

#### ❌ 잘못된 이름

```java
OutboxPoller          // Job 접미사 없음
OrderStatistics       // Job 접미사 없음
CleanupScheduler      // Scheduler는 사용 안 함
OrderTask             // Task는 사용 안 함
```

**이유:**
- ✅ 명확한 식별 (Job임을 즉시 알 수 있음)
- ✅ 일관된 네이밍 규칙
- ✅ AOP 로깅에서 클래스명 사용

---

## Scheduled 애노테이션 규칙

### Scheduling 옵션

| 방법 | 용도 | 예시 |
|---|---|-----|
| `fixedDelay` | 이전 실행 완료 후 N ms 대기 | Outbox Polling (10초) |
| `fixedRate` | N ms마다 실행 (이전 실행 무관) | Health Check (1분) |
| `cron` | Cron 표현식 | 일일 통계 (새벽 1시) |

```java
// fixedDelay - 권장 (중복 실행 방지)
@Scheduled(fixedDelayString = "${job.outbox.publish.fixed-delay:10000}")
@Override
public void execute() {
    // 비즈니스 로직
}

// cron - 정해진 시간에 실행
@Scheduled(cron = "0 0 1 * * *")  // 매일 새벽 1시
@Override
public void execute() {
    // 비즈니스 로직
}

// fixedRate - 주의 (이전 실행과 무관하게 실행)
@Scheduled(fixedRate = 60000)  // 1분마다
@Override
public void execute() {
    // 비즈니스 로직
}
```

---

## Multi-Thread 설정 ⭐

### 기본 동작

**Spring @Scheduled는 기본적으로 단일 스레드로 동작합니다.**

```
OutboxEventPublishJob (10초마다)
  ↓ 실행 완료 대기
OrderStatisticsJob (1시간마다)
  ↓ 실행 완료 대기
DataCleanupJob (2시간마다)
```

**문제:**
- ❌ Job이 순차적으로 실행됨
- ❌ 긴 실행 시간의 Job이 다른 Job을 블로킹
- ❌ 동시에 실행되어야 할 Job들이 대기

### Thread Pool 설정

**SchedulingConfig.java**로 Thread Pool을 설정합니다.

```java
// job/common/config/SchedulingConfig.java
@Configuration
@RequiredArgsConstructor
public class SchedulingConfig {

  private final SchedulingProperties properties;

  @Bean
  public ThreadPoolTaskScheduler taskScheduler() {
    ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler();
    
    // Thread Pool Size: 동시에 실행 가능한 Job 수
    scheduler.setPoolSize(properties.getPoolSize());
    
    // Thread 이름 Prefix (로깅, 디버깅 시 유용)
    scheduler.setThreadNamePrefix(properties.getThreadNamePrefix());
    
    // Daemon Thread 여부 (false: 애플리케이션 종료 시 작업 완료 대기)
    scheduler.setDaemon(false);
    
    // Graceful Shutdown: 종료 시 실행 중인 Job 완료 대기
    scheduler.setWaitForTasksToCompleteOnShutdown(true);
    
    // Shutdown 대기 시간 (초)
    scheduler.setAwaitTerminationSeconds(properties.getAwaitTerminationSeconds());
    
    scheduler.initialize();
    
    return scheduler;
  }
}
```

```java
// job/common/config/SchedulingProperties.java
@Component
@ConfigurationProperties(prefix = "job.scheduling")
@Getter
@Setter
public class SchedulingProperties {
    
    private int poolSize = 10;
    private String threadNamePrefix = "scheduled-job-";
    private int awaitTerminationSeconds = 60;
}
```

```yaml
# application.yml
job:
  scheduling:
    pool-size: 10
    thread-name-prefix: "scheduled-job-"
    await-termination-seconds: 60
```

### Thread Pool 적용 후

**여러 Job이 동시에 실행됩니다.**

```
OutboxEventPublishJob (10초마다) ──┐
OrderStatisticsJob (1시간마다) ├─→ Thread Pool (동시 실행)
DataCleanupJob (2시간마다) ────┘
```

**장점:**
- ✅ Job이 병렬로 실행
- ✅ 긴 실행 시간의 Job이 다른 Job을 블로킹하지 않음
- ✅ 더 높은 처리량

### Pool Size 결정

**권장:**
- **일반적인 경우**: 10-20
- **Job이 많은 경우**: Job 개수 × 1.5
- **CPU 집약적**: CPU 코어 수
- **I/O 집약적**: CPU 코어 수 × 2

**예시:**
```java
// Job 개수: 5개, I/O 집약적 (DB, Kafka)
scheduler.setPoolSize(10);  // 5 × 2
```

### Graceful Shutdown

**setWaitForTasksToCompleteOnShutdown(true)**
- 애플리케이션 종료 시 실행 중인 Job 완료 대기
- 데이터 유실 방지

**setAwaitTerminationSeconds(60)**
- 최대 60초 대기
- 초과 시 강제 종료

### Thread 이름 확인

**로그에서 Thread 이름 확인 가능:**
```
2025-01-12 10:00:00.123 INFO [scheduled-job-1] [OutboxEventPublishJob] Job started
2025-01-12 10:00:00.456 INFO [scheduled-job-2] [OrderStatisticsJob] Job started
2025-01-12 10:00:00.789 INFO [scheduled-job-3] [DataCleanupJob] Job started
```

### 주의사항

**1. Thread-Safe 필요**
```java
// ❌ 위험: 여러 Thread에서 공유되는 mutable 상태
@Component
public class UnsafeJob implements BaseScheduledJob {
    private int counter = 0;  // ❌ Thread-Safe 하지 않음
    
    @Scheduled(fixedDelay = 1000)
    @Override
    public void execute() {
        counter++;  // Race condition 발생 가능
    }
}

// ✅ 안전: Stateless 또는 Thread-Safe
@Component
public class SafeJob implements BaseScheduledJob {
    private final AtomicInteger counter = new AtomicInteger(0);  // ✅ Thread-Safe
    
    @Scheduled(fixedDelay = 1000)
    @Override
    public void execute() {
        counter.incrementAndGet();
    }
}
```

**2. 동시 실행 방지가 필요한 경우**

같은 Job이 중복 실행되면 안 되는 경우:

```java
@Component
public class CriticalJob implements BaseScheduledJob {
    
    private final AtomicBoolean running = new AtomicBoolean(false);
    
    @Scheduled(fixedDelay = 1000)
    @Override
    public void execute() {
        // 이미 실행 중이면 스킵
        if (!running.compareAndSet(false, true)) {
            log.warn("Job is already running, skipping this execution");
            return;
        }
        
        try {
            // 비즈니스 로직
        } finally {
            running.set(false);
        }
    }
}
```

**3. 분산 환경에서 중복 실행 방지**

여러 서버에서 동일한 Job이 실행되는 경우:
- ShedLock 라이브러리 사용 권장
- Redis, DB 등으로 분산 락 구현

---

## 설정 관리

### Properties 클래스 사용

**application.yml 설정은 @ConfigurationProperties로 매핑합니다.**

```java
// job/common/config/OutboxEventPublishProperties.java
@Component
@ConfigurationProperties(prefix = "job.outbox.publish")
@Getter
@Setter
public class OutboxEventPublishProperties {
    
    private boolean enabled = true;
    private long fixedDelay = 10000;
    private int batchSize = 100;
}
```

```yaml
# application.yml
job:
  outbox:
    polling:
      enabled: true
      fixed-delay: 10000
      batch-size: 100
```

### @ConditionalOnProperty로 활성화 제어

```java
@Component
@ConditionalOnProperty(
    prefix = "job.outbox.publish",
    name = "enabled",
    havingValue = "true",
    matchIfMissing = false
)
public class OutboxEventPublishJob implements BaseScheduledJob {
    // ...
}
```

**장점:**
- ✅ 환경별 Job 활성화/비활성화 가능
- ✅ 테스트 환경에서 Job 제외 가능
- ✅ `matchIfMissing = false`로 명시적 설정 강제 (안전)

---

## 비즈니스 로직 호출 규칙

### Domain Service 호출 (필수)

**Job은 Domain Service를 통해 비즈니스 로직을 호출해야 합니다.**

#### ✅ 좋은 예 - Domain Service 호출

```java
@Component
@RequiredArgsConstructor
public class OrderStatisticsJob implements BaseScheduledJob {
    
    private final OrderReader orderReader;  // Domain Service
    
    @Scheduled(cron = "0 0 1 * * *")
    @Override
    public void execute() {
        LocalDate yesterday = LocalDate.now().minusDays(1);
        
        // Domain Service 호출
        var statistics = orderReader.calculateStatistics(yesterday);
        
        log.info("Daily statistics calculated: {}", statistics);
    }
}

// Outbox Polling도 동일한 패턴
@Component
@RequiredArgsConstructor
public class OutboxEventPublishJob implements BaseScheduledJob {
    
    private final OutboxEventPublisher outboxEventPublisher;  // Domain Service
    
    @Scheduled(fixedDelay = 10000)
    @Override
    public void execute() {
        // Domain Service 호출
        int count = outboxEventPublisher.publishPendingEvents(100);
        
        if (count > 0) {
            log.info("Published {} events", count);
        }
    }
}
```

#### ❌ 나쁜 예 - Infrastructure 직접 호출

```java
// ❌ 나쁜 예 1: Repository 직접 호출
@Component
@RequiredArgsConstructor
public class OrderStatisticsJob implements BaseScheduledJob {
    
    private final OrderRepository orderRepository;  // ❌ 금지!
    
    @Scheduled(cron = "0 0 1 * * *")
    @Override
    public void execute() {
        // Repository 직접 호출 금지!
        List<Order> orders = orderRepository.findAll();
        
        // 비즈니스 로직 직접 구현 금지!
        long count = orders.stream()
            .filter(o -> o.getStatus() == OrderStatus.COMPLETED)
            .count();
    }
}

// ❌ 나쁜 예 2: Infrastructure 클래스 직접 의존
@Component
@RequiredArgsConstructor
public class OutboxEventPublishJob implements BaseScheduledJob {
    
    private final OutboxEventService outboxEventService;  // ❌ 금지! (Infrastructure)
    
    @Scheduled(fixedDelay = 10000)
    @Override
    public void execute() {
        // Infrastructure 직접 호출 금지!
        outboxEventService.publishPendingEvents(100);
    }
}
```

**규칙:**
- ✅ Domain Service만 호출
- ❌ Repository 직접 호출 금지
- ❌ Infrastructure 클래스 직접 의존 금지
- ❌ 비즈니스 로직 직접 구현 금지
- ❌ 트랜잭션 관리 금지 (Domain Service에서)

---

## 예외 처리

### AOP가 자동으로 처리

**ScheduledJobLoggingAspect가 자동으로 예외를 처리합니다.**

```java
@Component
public class OutboxEventPublishJob implements BaseScheduledJob {
    
    @Scheduled(fixedDelay = 10000)
    @Override
    public void execute() {
        // 예외 발생 시 AOP가 자동으로:
        // 1. 에러 로그 기록
        // 2. 예외 삼킴 (다음 실행 보장)
        outboxEventService.publishPendingEvents(batchSize);
    }
}
```

**자동 처리:**
```
2025-01-12 10:00:00.123 DEBUG [OutboxEventPublishJob] Job started
2025-01-12 10:00:00.456 ERROR [OutboxEventPublishJob] Job failed after 333ms: Connection timeout
  ... stack trace ...
```

### 특수한 예외 처리가 필요한 경우

```java
@Component
public class CustomJob implements BaseScheduledJob {
    
    @Scheduled(fixedDelay = 10000)
    @Override
    public void execute() {
        try {
            // 비즈니스 로직
        } catch (SpecificException e) {
            // 특수 처리
            log.warn("Specific error handled", e);
            // 예외를 다시 던지지 않으면 성공으로 간주
        }
    }
}
```

---

## 테스트 규칙

### Job 단위 테스트

```java
@ExtendWith(MockitoExtension.class)
class OutboxEventPublishJobTest {
    
    @InjectMocks
    private OutboxEventPublishJob job;
    
    @Mock
    private OutboxEventService outboxEventService;
    
    @Mock
    private OutboxEventPublishProperties properties;
    
    @Test
    void execute_publishesEvents_whenPendingEventsExist() {
        // given
        given(properties.getBatchSize()).willReturn(100);
        given(outboxEventService.publishPendingEvents(100)).willReturn(3);
        
        // when
        job.execute();
        
        // then
        verify(outboxEventService).publishPendingEvents(100);
    }
}
```

### 통합 테스트에서 Job 비활성화

```yaml
# src/test/resources/application.yml
job:
  outbox:
    polling:
      enabled: false  # 테스트에서 Job 비활성화
```

---

## 실전 예시: OutboxEventPublishJob

```java
package vroong.laas.order.job.outbox;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
import vroong.laas.order.core.domain.outbox.OutboxEventPublisher;
import vroong.laas.order.job.common.config.OutboxEventPublishProperties;

/**
 * Outbox Polling Job
 *
 * <p>Outbox 테이블에서 미전송 이벤트를 Kafka로 전송합니다.
 *
 * <p>실행 주기: 10초 (job.outbox.publish.fixed-delay)
 *
 * <p>AOP가 자동으로 로깅, 실행 시간 측정, 예외 처리를 수행합니다.
 *
 * <p>아키텍처:
 * <pre>
 * OutboxEventPublishJob (Job Layer)
 *   → OutboxEventPublisher (Domain Service)
 *     → OutboxEventClient (Port)
 *       → KafkaOutboxEventClient (Infrastructure Adapter)
 * </pre>
 */
@Component
@RequiredArgsConstructor
@Slf4j
@ConditionalOnProperty(
    prefix = "job.outbox.publish",
    name = "enabled",
    havingValue = "true",
    matchIfMissing = false
)
public class OutboxEventPublishJob implements BaseScheduledJob {
    
    private final OutboxEventPublisher outboxEventPublisher;  // Domain Service
    private final OutboxEventPublishProperties properties;
    
    /**
     * Outbox Polling 실행
     *
     * <p>ScheduledJobLoggingAspect가 자동으로 로깅 및 예외 처리를 수행합니다.
     */
    @Scheduled(fixedDelayString = "${job.outbox.publish.fixed-delay:10000}")
    @Override
    public void execute() {
        int publishedCount = outboxEventPublisher.publishPendingEvents(
            properties.getBatchSize()
        );
        
        if (publishedCount > 0) {
            log.info("Published {} events from outbox to Kafka", publishedCount);
        }
    }
}
```

---

## 체크리스트

매 Job 작성 시 확인:

- [ ] BaseScheduledJob 인터페이스 구현?
- [ ] 1개 클래스에 1개 @Scheduled 메서드만?
- [ ] 클래스 이름이 *Job으로 끝나는가?
- [ ] execute() 메서드에 @Scheduled 애노테이션?
- [ ] Domain Service만 호출?
- [ ] Repository 직접 호출 안 함?
- [ ] @ConditionalOnProperty로 활성화 제어?
- [ ] Properties 클래스로 설정 관리?

---

## 금지 사항

### ❌ 절대 하지 말 것

1. **여러 @Scheduled 메서드를 한 클래스에**
   ```java
   // ❌ 금지!
   @Component
   public class MultiJob implements BaseScheduledJob {
       @Scheduled(fixedDelay = 10000)
       @Override
       public void execute() { }
       
       @Scheduled(cron = "0 0 * * * *")
       public void anotherJob() { }
   }
   ```

2. **Repository 직접 호출**
   ```java
   // ❌ 금지!
   private final OrderRepository orderRepository;
   ```

3. **비즈니스 로직 직접 구현**
   ```java
   // ❌ 금지! Domain Service에서 구현
   @Override
   public void execute() {
       Order order = orderRepository.findById(1L).orElseThrow();
       order.calculateTotalAmount();  // 비즈니스 로직
   }
   ```

4. **트랜잭션 직접 관리**
   ```java
   // ❌ 금지! Domain Service에서 관리
   @Override
   @Transactional
   public void execute() { }
   ```

5. **Job 접미사 없는 이름**
   ```java
   // ❌ 금지!
   public class OutboxPoller implements BaseScheduledJob { }
   public class OrderStatistics implements BaseScheduledJob { }
   ```

---

## 중요 원칙

1. **BaseScheduledJob 인터페이스 구현** (필수)
2. **1개 클래스 = 1개 작업** (필수)
3. **클래스 이름은 *Job** (필수)
4. **기능별 패키지 구성** (outbox/, statistics/, cleanup/ 등)
5. **AOP가 자동 로깅/예외처리** (ScheduledJobLoggingAspect)
6. **Domain Service만 호출** (비즈니스 로직 금지)
7. **@ConditionalOnProperty로 활성화 제어**
8. **Properties 클래스로 설정 관리**
