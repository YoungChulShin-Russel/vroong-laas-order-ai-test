---
alwaysApply: true
---
## 🛠 기술 스택

### 필수 라이브러리

```gradle
dependencies {
    // JUnit 5
    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.0'
    
    // AssertJ (가독성 좋은 assertion)
    testImplementation 'org.assertj:assertj-core:3.24.0'
    
    // Mockito (Mock 객체)
    testImplementation 'org.mockito:mockito-core:5.5.0'
    testImplementation 'org.mockito:mockito-junit-jupiter:5.5.0'
    
    // Fixture Monkey (테스트 객체 생성)
    testImplementation 'com.navercorp.fixturemonkey:fixture-monkey-starter:1.0.0'
    
    // Spring Boot Test
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}
```

### 주요 도구

| 도구 | 용도 | 사용 위치 |
|------|------|-----------|
| **JUnit 5** | 테스트 프레임워크 | 모든 테스트 |
| **AssertJ** | Assertion | 모든 테스트 |
| **Mockito** | Mock 객체 | Application, Interface Layer |
| **Fixture Monkey** | 테스트 객체 생성 | 모든 테스트 |
| **@DataJpaTest** | Repository 테스트 | Infrastructure Layer |
| **@WebMvcTest** | Controller 테스트 | Interface Layer |

---

## 📋 계층별 테스트 전략

### 1. Domain Layer 테스트

**특징:**
- 순수 Java 단위 테스트
- 외부 의존성 없음
- 비즈니스 로직 검증

**테스트 대상:**
- Domain Entity
- Value Object
- Domain Service
- Domain Exception

**예시:**
```java
// core/src/test/java/vroong/laas/order/domain/order/OrderTest.java
class OrderTest {
    
    private FixtureMonkey fixtureMonkey;
    
    @BeforeEach
    void setUp() {
        fixtureMonkey = FixtureMonkey.builder()
            .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE)
            .build();
    }
    
    @Test
    @DisplayName("주문을 취소하면 상태가 CANCELLED로 변경된다")
    void cancel_order_changes_status_to_cancelled() {
        // given
        Order order = fixtureMonkey.giveMeBuilder(Order.class)
            .set("status", OrderStatus.PENDING)
            .sample();
        
        String reason = "고객 요청";
        
        // when
        order.cancel(reason);
        
        // then
        assertThat(order.getStatus()).isEqualTo(OrderStatus.CANCELLED);
        assertThat(order.getCancelReason()).isEqualTo(reason);
    }
    
    @Test
    @DisplayName("이미 취소된 주문은 다시 취소할 수 없다")
    void cannot_cancel_already_cancelled_order() {
        // given
        Order order = fixtureMonkey.giveMeBuilder(Order.class)
            .set("status", OrderStatus.CANCELLED)
            .sample();
        
        // when & then
        assertThatThrownBy(() -> order.cancel("재취소"))
            .isInstanceOf(OrderAlreadyCancelledException.class)
            .hasMessage("이미 취소된 주문입니다");
    }
}
```

---

### 📌 Domain Layer 테스트 실전 가이드

#### 1. Spring Context 사용 금지 ⭐⭐⭐

**Domain Layer는 순수 Java 테스트여야 합니다. Spring 의존성 절대 금지!**

```java
// ❌ 잘못된 예 - Spring Context 사용
@Component  // 금지!
public class OrderFixtures {
    @Autowired
    private FixtureMonkey fixtureMonkey;  // 금지!
}

@SpringBootTest  // Domain Layer에서 금지!
class OrderTest {
    @Autowired
    private OrderFixtures fixtures;
}

// ✅ 올바른 예 - 순수 Java
public class OrderFixtures {
    private final FixtureMonkey fixtureMonkey;
    
    public OrderFixtures(FixtureMonkey fixtureMonkey) {
        this.fixtureMonkey = fixtureMonkey;
    }
}

class OrderTest {
    private OrderFixtures orderFixtures;
    
    @BeforeEach
    void setUp() {
        FixtureMonkey fixtureMonkey = FixtureMonkey.builder()
            .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE)
            .defaultNotNull(true)
            .build();
        
        orderFixtures = new OrderFixtures(fixtureMonkey);
    }
}
```

**왜 중요한가?**
- Domain Layer는 Infrastructure에 의존하지 않음
- 빠른 테스트 실행 (Spring Context 로딩 없음)
- 순수한 비즈니스 로직 검증

---

#### 2. 생성자 vs 팩토리 메서드 패턴 ⭐⭐⭐

**생성자에서 필수 값 체크, create()는 비즈니스 규칙용**

```java
public class Order {
    
    // 생성자 - 필수 값 체크 (항상 실행)
    public Order(
        Long id,
        String orderNumber,
        OrderStatus status,
        List<OrderItem> items,
        Origin origin,
        Destination destination,
        DeliveryPolicy deliveryPolicy,
        Instant orderedAt,
        Instant deliveredAt,
        Instant cancelledAt
    ) {
        // 필수 값 체크
        if (orderNumber == null || orderNumber.isBlank()) {
            throw new IllegalArgumentException("주문번호는 필수입니다");
        }
        if (items == null || items.isEmpty()) {
            throw new IllegalArgumentException("주문 아이템은 최소 1개 이상이어야 합니다");
        }
        if (origin == null) {
            throw new IllegalArgumentException("출발지는 필수입니다");
        }
        if (destination == null) {
            throw new IllegalArgumentException("도착지는 필수입니다");
        }
        
        // 할당
        this.id = id;
        this.orderNumber = orderNumber;
        this.status = status;
        this.items = new ArrayList<>(items);
        this.origin = origin;
        this.destination = destination;
        this.deliveryPolicy = deliveryPolicy;
        this.orderedAt = orderedAt;
        this.deliveredAt = deliveredAt;
        this.cancelledAt = cancelledAt;
    }
    
    // create() - 비즈니스 규칙 + 초기 상태로 생성
    public static Order create(
        String orderNumber,
        List<OrderItem> items,
        Origin origin,
        Destination destination,
        DeliveryPolicy deliveryPolicy
    ) {
        // 추가 비즈니스 검증 (선택적)
        validateBusinessRules(items, origin, destination);
        
        // 초기 상태로 생성
        return new Order(
            null,                  // id는 나중에 할당
            orderNumber,
            OrderStatus.CREATED,   // 초기 상태
            items,
            origin,
            destination,
            deliveryPolicy,
            Instant.now(),         // 현재 시간
            null,                  // deliveredAt
            null                   // cancelledAt
        );
    }
}
```

**사용 구분:**

| 방법 | 용도 | 검증 | 사용처 |
|------|------|------|--------|
| **`create()`** | 새 주문 생성 | 비즈니스 규칙 ✅ | 프로덕션 (UseCase) |
| **생성자** | 객체 복원/테스트 | 필수 값만 ✅ | 테스트, Infrastructure |

```java
// 프로덕션 - create() 사용
Order order = Order.create(
    "ORD-001", items, origin, destination, policy
);

// 테스트 - 생성자 직접 사용 (다양한 상태)
Order deliveredOrder = new Order(
    1L, "ORD-001", OrderStatus.DELIVERED, items, 
    origin, destination, policy,
    Instant.now().minusSeconds(3600),
    Instant.now(),  // deliveredAt
    null
);

// Infrastructure - 생성자 사용 (DB → Domain)
public Order toDomain() {
    return new Order(
        this.id, this.orderNumber, this.status,
        this.items.stream()...
    );
}
```

---

#### 3. ConstructorPropertiesArbitraryIntrospector 필수 ⭐⭐⭐

**record, 불변 객체를 위해 반드시 설정!**

```java
// ✅ 필수 설정
FixtureMonkey fixtureMonkey = FixtureMonkey.builder()
    .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE)  // ⭐
    .defaultNotNull(true)  // null 방지
    .build();

// record에서 작동
public record Contact(String name, String phoneNumber) { }

Contact contact = fixtureMonkey.giveMeOne(Contact.class);  // ✅ 작동!

// 불변 객체에서 작동
@Getter
@AllArgsConstructor
public class Order {
    private final String orderNumber;
    // ...
}

Order order = fixtureMonkey.giveMeOne(Order.class);  // ✅ 작동!
```

**없으면?**
```java
// ❌ ConstructorPropertiesArbitraryIntrospector 없이
FixtureMonkey fixtureMonkey = FixtureMonkey.builder().build();

Contact contact = fixtureMonkey.giveMeOne(Contact.class);
// → 에러! record는 기본 생성자가 없음
```

---

#### 4. Arbitraries와 FixtureMonkey 조합 ⭐⭐

**범위가 있는 랜덤 값 생성**

```java
import net.jqwik.api.Arbitraries;

public class OrderFixtures {
    
    private final FixtureMonkey fixtureMonkey;
    
    // Arbitraries로 범위 지정
    public OrderItem randomOrderItem() {
        String itemName = "상품" + fixtureMonkey.giveMeOne(Integer.class);
        int quantity = Arbitraries.integers().between(1, 10).sample();
        Money price = new Money(
            BigDecimal.valueOf(Arbitraries.longs().between(1000L, 100000L).sample())
        );
        String category = Arbitraries.of("식품", "생활용품", "의류", "전자제품").sample();
        
        return new OrderItem(itemName, quantity, price, category, null, null);
    }
    
    // FixtureMonkey.giveMeBuilder()와 Arbitraries 조합
    public Contact randomContact() {
        return fixtureMonkey.giveMeBuilder(Contact.class)
            .set("name", "테스터" + fixtureMonkey.giveMeOne(Integer.class))
            .set("phoneNumber", 
                "010-" + 
                Arbitraries.strings().numeric().ofLength(4).sample() + 
                "-" + 
                Arbitraries.strings().numeric().ofLength(4).sample())
            .sample();
    }
    
    public LatLng randomLatLng() {
        return fixtureMonkey.giveMeBuilder(LatLng.class)
            .set("latitude", 
                Arbitraries.doubles().between(37.0, 38.0)
                    .map(BigDecimal::valueOf))
            .set("longitude", 
                Arbitraries.doubles().between(126.0, 127.0)
                    .map(BigDecimal::valueOf))
            .sample();
    }
}
```

**주요 Arbitraries 메서드:**

```java
// 정수 범위
Arbitraries.integers().between(1, 10).sample()

// Long 범위
Arbitraries.longs().between(1000L, 100000L).sample()

// Double 범위
Arbitraries.doubles().between(37.0, 38.0).sample()

// 목록에서 선택
Arbitraries.of("A", "B", "C", "D").sample()

// 숫자 문자열
Arbitraries.strings().numeric().ofLength(4).sample()  // "1234"

// 알파벳 문자열
Arbitraries.strings().alpha().ofLength(10).sample()  // "abcdEFGHij"
```

---

#### 5. 실전 Fixture 패턴 ⭐⭐

**상태별 Fixture 메서드 제공**

```java
public class OrderFixtures {
    
    private final FixtureMonkey fixtureMonkey;
    
    public OrderFixtures(FixtureMonkey fixtureMonkey) {
        this.fixtureMonkey = fixtureMonkey;
    }
    
    // 기본 주문 (CREATED 상태)
    public Order order() {
        return new Order(
            null,
            generateOrderNumber(),
            OrderStatus.CREATED,
            randomOrderItems(),
            randomOrigin(),
            randomDestination(),
            randomDeliveryPolicy(),
            Instant.now(),
            null,
            null
        );
    }
    
    // 특정 주문번호로 생성
    public Order order(String orderNumber) {
        return new Order(
            null,
            orderNumber,
            OrderStatus.CREATED,
            randomOrderItems(),
            randomOrigin(),
            randomDestination(),
            randomDeliveryPolicy(),
            Instant.now(),
            null,
            null
        );
    }
    
    // 배송완료 주문
    public Order deliveredOrder() {
        return new Order(
            fixtureMonkey.giveMeOne(Long.class),
            generateOrderNumber(),
            OrderStatus.DELIVERED,
            randomOrderItems(),
            randomOrigin(),
            randomDestination(),
            randomDeliveryPolicy(),
            Instant.now().minusSeconds(3600),
            Instant.now(),  // deliveredAt
            null
        );
    }
    
    // 취소된 주문
    public Order cancelledOrder() {
        return new Order(
            fixtureMonkey.giveMeOne(Long.class),
            generateOrderNumber(),
            OrderStatus.CANCELLED,
            randomOrderItems(),
            randomOrigin(),
            randomDestination(),
            randomDeliveryPolicy(),
            Instant.now().minusSeconds(3600),
            null,
            Instant.now()  // cancelledAt
        );
    }
    
    // 특정 ID로 생성
    public Order orderWithId(Long id) {
        return new Order(
            id,
            generateOrderNumber(),
            OrderStatus.CREATED,
            randomOrderItems(),
            randomOrigin(),
            randomDestination(),
            randomDeliveryPolicy(),
            Instant.now(),
            null,
            null
        );
    }
    
    // 특정 상태로 생성
    public Order orderWithStatus(OrderStatus status) {
        Instant deliveredAt = status == OrderStatus.DELIVERED ? Instant.now() : null;
        Instant cancelledAt = status == OrderStatus.CANCELLED ? Instant.now() : null;
        
        return new Order(
            null,
            generateOrderNumber(),
            status,
            randomOrderItems(),
            randomOrigin(),
            randomDestination(),
            randomDeliveryPolicy(),
            Instant.now().minusSeconds(3600),
            deliveredAt,
            cancelledAt
        );
    }
    
    // Value Object 랜덤 생성 헬퍼
    public List<OrderItem> randomOrderItems() {
        int count = Math.abs(fixtureMonkey.giveMeOne(Integer.class) % 3) + 1;
        return List.of(
            randomOrderItem(),
            randomOrderItem(),
            randomOrderItem()
        ).subList(0, count);
    }
    
    public OrderItem randomOrderItem() {
        // Arbitraries 활용
        String itemName = "상품" + Math.abs(fixtureMonkey.giveMeOne(Integer.class) % 1000);
        int quantity = Arbitraries.integers().between(1, 10).sample();
        Money price = new Money(
            BigDecimal.valueOf(Arbitraries.longs().between(1000L, 100000L).sample())
        );
        String category = Arbitraries.of("식품", "생활용품", "의류", "전자제품").sample();
        
        return new OrderItem(itemName, quantity, price, category, null, null);
    }
    
    public Contact randomContact() {
        return fixtureMonkey.giveMeBuilder(Contact.class)
            .set("name", "테스터" + fixtureMonkey.giveMeOne(Integer.class))
            .set("phoneNumber", 
                "010-" + 
                Arbitraries.strings().numeric().ofLength(4).sample() + 
                "-" + 
                Arbitraries.strings().numeric().ofLength(4).sample())
            .sample();
    }
    
    private String generateOrderNumber() {
        return "ORD-" + System.currentTimeMillis();
    }
}
```

**테스트에서 사용:**

```java
class OrderTest {
    
    private OrderFixtures orderFixtures;
    
    @BeforeEach
    void setUp() {
        FixtureMonkey fixtureMonkey = FixtureMonkey.builder()
            .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE)
            .defaultNotNull(true)
            .build();
        
        orderFixtures = new OrderFixtures(fixtureMonkey);
    }
    
    @Test
    void test_with_created_order() {
        Order order = orderFixtures.order();
        // 테스트...
    }
    
    @Test
    void test_with_delivered_order() {
        Order order = orderFixtures.deliveredOrder();
        // 테스트...
    }
    
    @Test
    void test_with_specific_status() {
        Order order = orderFixtures.orderWithStatus(OrderStatus.CANCELLED);
        // 테스트...
    }
}
```

---

### 2. Application Layer 테스트

**특징:**
- UseCase 테스트
- Mock으로 Port 대체
- 흐름 검증 (Given-When-Then)

**테스트 대상:**
- UseCase
- Command/Query

**예시:**
```java
// core/src/test/java/vroong/laas/order/application/order/CancelOrderUseCaseTest.java
@ExtendWith(MockitoExtension.class)
class CancelOrderUseCaseTest {
    
    @InjectMocks
    private CancelOrderUseCase sut;
    
    @Mock
    private OrderStore orderStore;
    
    @Mock
    private EventPublisher eventPublisher;
    
    private FixtureMonkey fixtureMonkey;
    
    @BeforeEach
    void setUp() {
        fixtureMonkey = FixtureMonkey.builder()
            .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE)
            .build();
    }
    
    @Test
    @DisplayName("주문을 취소하고 이벤트를 발행한다")
    void cancel_order_and_publish_event() {
        // given
        Long orderId = 1L;
        String reason = "고객 요청";
        
        Order order = fixtureMonkey.giveMeBuilder(Order.class)
            .set("id", orderId)
            .set("status", OrderStatus.PENDING)
            .sample();
        
        given(orderStore.findById(orderId))
            .willReturn(Optional.of(order));
        
        CancelOrderCommand command = new CancelOrderCommand(orderId, reason);
        
        // when
        sut.execute(command);
        
        // then
        assertThat(order.getStatus()).isEqualTo(OrderStatus.CANCELLED);
        
        verify(orderStore).save(order);
        verify(eventPublisher).publish(any(OrderCancelledEvent.class));
    }
    
    @Test
    @DisplayName("존재하지 않는 주문은 취소할 수 없다")
    void cannot_cancel_non_existing_order() {
        // given
        Long orderId = 999L;
        
        given(orderStore.findById(orderId))
            .willReturn(Optional.empty());
        
        CancelOrderCommand command = new CancelOrderCommand(orderId, "사유");
        
        // when & then
        assertThatThrownBy(() -> sut.execute(command))
            .isInstanceOf(OrderNotFoundException.class);
        
        verify(orderStore, never()).save(any());
        verify(eventPublisher, never()).publish(any());
    }
}
```

---

### 3. Infrastructure Layer 테스트

**특징:**
- Repository 통합 테스트
- @DataJpaTest 사용
- 실제 DB(H2) 사용

**테스트 대상:**
- Repository Adapter
- JPA Entity
- Query

**예시:**
```java
// infrastructure/src/test/java/vroong/laas/order/infrastructure/storage/db/order/OrderStoreAdapterTest.java
@DataJpaTest
@Import(OrderStoreAdapter.class)
class OrderStoreAdapterTest {
    
    @Autowired
    private OrderStoreAdapter orderStoreAdapter;
    
    @Autowired
    private OrderJpaRepository orderJpaRepository;
    
    private FixtureMonkey fixtureMonkey;
    
    @BeforeEach
    void setUp() {
        fixtureMonkey = FixtureMonkey.builder()
            .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE)
            .build();
    }
    
    @Test
    @DisplayName("주문을 저장하고 조회할 수 있다")
    void save_and_find_order() {
        // given
        Order order = fixtureMonkey.giveMeBuilder(Order.class)
            .set("id", null)  // 신규 주문
            .set("status", OrderStatus.PENDING)
            .sample();
        
        // when
        Order saved = orderStoreAdapter.save(order);
        Order found = orderStoreAdapter.findById(saved.getId()).orElseThrow();
        
        // then
        assertThat(found.getId()).isEqualTo(saved.getId());
        assertThat(found.getStatus()).isEqualTo(OrderStatus.PENDING);
    }
    
    @Test
    @DisplayName("주문과 아이템을 함께 조회할 수 있다")
    void find_order_with_items() {
        // given
        OrderJpaEntity entity = fixtureMonkey.giveMeBuilder(OrderJpaEntity.class)
            .set("id", null)
            .size("items", 3)
            .sample();
        
        OrderJpaEntity saved = orderJpaRepository.save(entity);
        
        // when
        Order order = orderStoreAdapter.findByIdWithItems(saved.getId()).orElseThrow();
        
        // then
        assertThat(order.getItems()).hasSize(3);
    }
}
```

---

### 4. Interface Layer 테스트

**특징:**
- Controller 테스트
- @WebMvcTest 사용
- API 계약 검증

**테스트 대상:**
- Controller
- Request/Response DTO
- Exception Handler

**예시:**
```java
// api/src/test/java/vroong/laas/order/api/web/order/OrderControllerTest.java
@WebMvcTest(OrderController.class)
class OrderControllerTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @MockBean
    private CancelOrderUseCase cancelOrderUseCase;
    
    @Autowired
    private ObjectMapper objectMapper;
    
    private FixtureMonkey fixtureMonkey;
    
    @BeforeEach
    void setUp() {
        fixtureMonkey = FixtureMonkey.builder()
            .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE)
            .build();
    }
    
    @Test
    @DisplayName("주문 취소 API - 성공")
    void cancel_order_success() throws Exception {
        // given
        Long orderId = 1L;
        
        CancelOrderRequest request = fixtureMonkey.giveMeBuilder(CancelOrderRequest.class)
            .set("reason", "고객 요청")
            .sample();
        
        // when & then
        mockMvc.perform(
                post("/api/orders/{orderId}/cancel", orderId)
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(objectMapper.writeValueAsString(request))
            )
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.success").value(true));
        
        verify(cancelOrderUseCase).execute(any(CancelOrderCommand.class));
    }
    
    @Test
    @DisplayName("주문 취소 API - 유효성 검증 실패")
    void cancel_order_validation_fail() throws Exception {
        // given
        Long orderId = 1L;
        
        CancelOrderRequest request = new CancelOrderRequest(null);  // reason 누락
        
        // when & then
        mockMvc.perform(
                post("/api/orders/{orderId}/cancel", orderId)
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(objectMapper.writeValueAsString(request))
            )
            .andExpect(status().isBadRequest())
            .andExpect(jsonPath("$.errorCode").value("INVALID_INPUT"));
    }
}
```

---

## 5. REST Docs - API 문서 자동 생성 ⭐

**특징:**
- Controller 테스트와 함께 API 문서 자동 생성
- **@WebMvcTest 사용** (Web Layer만 로드, 빠른 실행)
- **FixtureMonkey 사용 안 함** (일관된 문서를 위해 고정 데이터 사용)
- 커스텀 템플릿으로 Constraints 컬럼 추가

### REST Docs 테스트 템플릿

```java
// api/src/test/java/vroong/laas/order/api/web/order/OrderControllerTest.java
@WebMvcTest(
    controllers = OrderController.class,
    excludeFilters = @ComponentScan.Filter(
        type = FilterType.REGEX,
        pattern = "vroong.laas.order.api.web.common.logging.*"
    )
)
@AutoConfigureRestDocs
@Import({RestDocsConfiguration.class, WebApiControllerAdvice.class})
class OrderControllerTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @MockBean
    private OrderFacade orderFacade;
    
    @Autowired
    private ObjectMapper objectMapper;
    
    @Autowired
    private RestDocumentationResultHandler restDocs;
    
    @Test
    @DisplayName("주문 생성 API")
    void createOrder_success() throws Exception {
        // given - 고정된 테스트 데이터 사용 (FixtureMonkey 사용 안 함)
        CreateOrderRequest request = CreateOrderRequest.builder()
            .items(List.of(
                OrderItemDto.builder()
                    .itemName("상품A")
                    .quantity(2)
                    .price(new BigDecimal("10000"))
                    .category("식품")
                    .build()
            ))
            .origin(OriginDto.builder()
                .contact(ContactDto.builder()
                    .name("발송자")
                    .phoneNumber("010-1234-5678")
                    .build())
                .address(AddressDto.builder()
                    .jibnunAddress("서울시 강남구 역삼동 123")
                    .roadAddress("서울시 강남구 테헤란로 123")
                    .detailAddress("1층")
                    .build())
                .latLng(LatLngDto.builder()
                    .latitude(new BigDecimal("37.123456"))
                    .longitude(new BigDecimal("127.123456"))
                    .build())
                .build())
            .destination(DestinationDto.builder()
                .contact(ContactDto.builder()
                    .name("수령자")
                    .phoneNumber("010-9876-5432")
                    .build())
                .address(AddressDto.builder()
                    .jibnunAddress("서울시 서초구 서초동 456")
                    .roadAddress("서울시 서초구 서초대로 456")
                    .detailAddress("2층")
                    .build())
                .latLng(LatLngDto.builder()
                    .latitude(new BigDecimal("37.234567"))
                    .longitude(new BigDecimal("127.234567"))
                    .build())
                .entranceInfo(EntranceInfoDto.builder()
                    .entrancePassword("1234")
                    .entranceNote("현관 비밀번호는 1234입니다")
                    .build())
                .build())
            .deliveryPolicy(DeliveryPolicyDto.builder()
                .pickupDueAt(Instant.now().plusSeconds(3600))
                .deliveryDueAt(Instant.now().plusSeconds(7200))
                .build())
            .build();
        
        Order mockOrder = Order.builder()
            .id(1L)
            .orderNumber(OrderNumber.of("ORD-20250112-001"))
            .status(OrderStatus.CREATED)
            .items(request.toItems())
            .origin(request.toOrigin())
            .destination(request.toDestination())
            .deliveryPolicy(request.toDeliveryPolicy())
            .orderedAt(Instant.now())
            .build();
        
        given(orderFacade.createOrder(any(CreateOrderCommand.class)))
            .willReturn(mockOrder);
        
        // when & then
        mockMvc.perform(post("/api/v1/orders")
                .contentType(APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.id").value(1))
            .andExpect(jsonPath("$.orderNumber").value("ORD-20250112-001"))
            .andExpect(jsonPath("$.status").value("CREATED"))
            .andDo(restDocs.document(
                requestFields(
                    fieldWithPath("items[]").description("주문 아이템 목록")
                        .attributes(key("constraints").value("최소 1개")),
                    fieldWithPath("items[].itemName").description("상품명"),
                    fieldWithPath("items[].quantity").description("수량")
                        .attributes(key("constraints").value("1 이상")),
                    fieldWithPath("items[].price").description("가격"),
                    fieldWithPath("items[].category").description("카테고리"),
                    fieldWithPath("origin.contact.name").description("발송자 이름"),
                    fieldWithPath("origin.contact.phoneNumber").description("발송자 전화번호"),
                    // ... 기타 필드
                ),
                responseFields(
                    fieldWithPath("id").description("주문 ID"),
                    fieldWithPath("orderNumber").description("주문 번호"),
                    fieldWithPath("status").description("주문 상태")
                        .attributes(key("constraints").value("CREATED, DELIVERED, CANCELLED")),
                    // ... 기타 필드
                )
            ));
    }
}
```

### RestDocsConfiguration (공통 설정)

```java
// api/src/test/java/vroong/laas/order/api/config/RestDocsConfiguration.java
@TestConfiguration
public class RestDocsConfiguration {
    
    @Bean
    public RestDocumentationResultHandler write() {
        return MockMvcRestDocumentation.document(
            "{class-name}/{method-name}",
            preprocessRequest(prettyPrint()),
            preprocessResponse(prettyPrint())
        );
    }
}
```

### 커스텀 템플릿 (Constraints 컬럼 추가)

**중요:** 템플릿 경로는 반드시 `src/test/resources/org/springframework/restdocs/templates/asciidoctor/`이어야 합니다. (Spring REST Docs 고정 규칙)

```
// api/src/test/resources/org/springframework/restdocs/templates/asciidoctor/request-fields.snippet
|===
|Path|Type|Description|Constraints

{{#fields}}
|{{#tableCellContent}}`+{{path}}+`{{/tableCellContent}}
|{{#tableCellContent}}`+{{type}}+`{{/tableCellContent}}
|{{#tableCellContent}}{{description}}{{/tableCellContent}}
|{{#tableCellContent}}{{#constraints}}{{.}}{{/constraints}}{{^constraints}}-{{/constraints}}{{/tableCellContent}}

{{/fields}}
|===
```

```
// api/src/test/resources/org/springframework/restdocs/templates/asciidoctor/response-fields.snippet
|===
|Path|Type|Description|Constraints

{{#fields}}
|{{#tableCellContent}}`+{{path}}+`{{/tableCellContent}}
|{{#tableCellContent}}`+{{type}}+`{{/tableCellContent}}
|{{#tableCellContent}}{{description}}{{/tableCellContent}}
|{{#tableCellContent}}{{#constraints}}{{.}}{{/constraints}}{{^constraints}}-{{/constraints}}{{/tableCellContent}}

{{/fields}}
|===
```

### 주요 규칙

1. **@WebMvcTest 사용 (필수)**
   - `@SpringBootTest` 대신 `@WebMvcTest` 사용
   - Web Layer만 로드하여 빠른 테스트 실행
   - 필요한 Bean은 `@Import`로 명시적 추가

2. **FixtureMonkey 사용 안 함 (필수)**
   - REST Docs는 일관된 문서가 필요
   - 고정된 테스트 데이터 사용
   - 빌더 패턴으로 가독성 있게 작성

3. **WebApiControllerAdvice Import (필수)**
   - `@WebMvcTest`는 `@ControllerAdvice`를 자동으로 로드하지 않음
   - `@Import({WebApiControllerAdvice.class})`로 명시적 추가

4. **RequestResponseLoggingFilter 제외 (필수)**
   - `@WebMvcTest`는 `LoggingProperties` Bean을 로드하지 않음
   - `excludeFilters`로 로깅 필터 제외

5. **커스텀 템플릿 경로 (고정)**
   - 반드시 `src/test/resources/org/springframework/restdocs/templates/asciidoctor/`
   - 다른 경로는 Spring REST Docs가 인식하지 못함

### 체크리스트

- [ ] `@WebMvcTest` 사용 (not `@SpringBootTest`)
- [ ] `@AutoConfigureRestDocs` 추가
- [ ] `@Import({RestDocsConfiguration.class, WebApiControllerAdvice.class})` 추가
- [ ] `excludeFilters`로 `RequestResponseLoggingFilter` 제외
- [ ] FixtureMonkey 제거, 고정 데이터 사용
- [ ] 커스텀 템플릿 경로 확인 (`org/springframework/restdocs/templates/asciidoctor/`)
- [ ] Constraints 추가 (`.attributes(key("constraints").value(...))`)

### 자주하는 실수

**❌ 잘못된 템플릿 경로**
```
src/test/resources/restdocs/templates/asciidoctor/  ← 인식 안 됨!
```

**✅ 올바른 템플릿 경로**
```
src/test/resources/org/springframework/restdocs/templates/asciidoctor/  ← 필수!
```

**❌ FixtureMonkey 사용**
```java
Order order = fixtureMonkey.giveMeOne(Order.class);  // 랜덤 데이터 → 문서가 매번 달라짐
```

**✅ 고정 데이터 사용**
```java
Order order = Order.builder()
    .id(1L)
    .orderNumber(OrderNumber.of("ORD-20250112-001"))
    .build();  // 고정 데이터 → 일관된 문서
```

**❌ @SpringBootTest 사용**
```java
@SpringBootTest  // 전체 Context 로드 → 느림
@AutoConfigureMockMvc
class OrderControllerTest { }
```

**✅ @WebMvcTest 사용**
```java
@WebMvcTest(OrderController.class)  // Web Layer만 로드 → 빠름
@AutoConfigureRestDocs
class OrderControllerTest { }
```

---

## 🎯 Fixture Monkey 사용 규칙

### 1. 설정

**공통 Fixture 설정 클래스 작성:**

```java
// src/test/java/vroong/laas/order/fixtures/FixtureConfig.java
@TestConfiguration
public class FixtureConfig {
    
    @Bean
    public FixtureMonkey fixtureMonkey() {
        return FixtureMonkey.builder()
            .objectIntrospector(ConstructorPropertiesArbitraryIntrospector.INSTANCE)
            .defaultNotNull(true)
            .build();
    }
}
```

---

### 2. 기본 사용법

#### 단일 객체 생성
```java
// 랜덤 객체
Order order = fixtureMonkey.giveMeOne(Order.class);

// 여러 객체
List<Order> orders = fixtureMonkey.giveMe(Order.class, 10);
```

#### 커스터마이징
```java
// Builder 패턴
Order order = fixtureMonkey.giveMeBuilder(Order.class)
    .set("status", OrderStatus.CONFIRMED)
    .set("totalAmount", Money.of(10000))
    .set("items[0].quantity", 5)
    .sample();

// 필드 제외
Order order = fixtureMonkey.giveMeBuilder(Order.class)
    .setNull("cancelReason")
    .sample();

// 범위 지정
Order order = fixtureMonkey.giveMeBuilder(Order.class)
    .size("items", 3, 5)  // 3~5개
    .sample();
```

---

### 3. 재사용 가능한 Fixture 클래스

**위치:** `src/test/java/.../fixtures/`

**네이밍:** `{Entity}Fixtures.java`

**예시:**
```java
// src/test/java/vroong/laas/order/fixtures/OrderFixtures.java
@Component
public class OrderFixtures {
    
    private final FixtureMonkey fixtureMonkey;
    
    public OrderFixtures(FixtureMonkey fixtureMonkey) {
        this.fixtureMonkey = fixtureMonkey;
    }
    
    // 기본 주문
    public ArbitraryBuilder<Order> order() {
        return fixtureMonkey.giveMeBuilder(Order.class)
            .set("status", OrderStatus.PENDING);
    }
    
    // 확정된 주문
    public ArbitraryBuilder<Order> confirmedOrder() {
        return order()
            .set("status", OrderStatus.CONFIRMED)
            .set("confirmedAt", LocalDateTime.now());
    }
    
    // 취소된 주문
    public ArbitraryBuilder<Order> cancelledOrder() {
        return order()
            .set("status", OrderStatus.CANCELLED)
            .set("cancelReason", "고객 요청");
    }
    
    // 특정 금액의 주문
    public ArbitraryBuilder<Order> orderWithAmount(Money amount) {
        return order()
            .set("totalAmount", amount);
    }
}
```

**사용:**
```java
@SpringBootTest
class OrderServiceTest {
    
    @Autowired
    private OrderFixtures orderFixtures;
    
    @Test
    void test() {
        // 확정된 주문 생성
        Order order = orderFixtures.confirmedOrder().sample();
        
        // 추가 커스터마이징
        Order customOrder = orderFixtures.confirmedOrder()
            .set("totalAmount", Money.of(50000))
            .sample();
    }
}
```

---

### 4. 계층별 Fixture 구성

```
src/test/java/vroong/laas/order/fixtures/
├── domain/
│   ├── OrderFixtures.java          # Domain Entity
│   ├── OrderItemFixtures.java
│   └── MoneyFixtures.java          # Value Object
├── application/
│   ├── CreateOrderCommandFixtures.java   # Command
│   └── CancelOrderCommandFixtures.java
├── infrastructure/
│   └── OrderJpaEntityFixtures.java       # JPA Entity
└── api/
    ├── CreateOrderRequestFixtures.java   # Request DTO
    └── OrderResponseFixtures.java        # Response DTO
```

---

## 📝 테스트 작성 가이드

### 1. Given-When-Then 패턴

모든 테스트는 Given-When-Then 구조를 따릅니다.

```java
@Test
void test_example() {
    // given (준비)
    // - 테스트 데이터 생성
    // - Mock 동작 정의
    Order order = fixtureMonkey.giveMeOne(Order.class);
    given(orderStore.findById(1L)).willReturn(Optional.of(order));
    
    // when (실행)
    // - 테스트할 메서드 호출
    Order result = orderService.getOrder(1L);
    
    // then (검증)
    // - 결과 검증
    // - 상태 변경 검증
    // - Mock 호출 검증
    assertThat(result).isEqualTo(order);
    verify(orderStore).findById(1L);
}
```

---

### 2. 테스트 네이밍 규칙

**형식:** `{테스트_대상}_{조건}_{예상_결과}`

```java
// ✅ 좋은 예
@Test
void cancel_order_with_pending_status_changes_to_cancelled() { }

@Test
void cancel_already_cancelled_order_throws_exception() { }

// ❌ 나쁜 예
@Test
void test1() { }

@Test
void cancelTest() { }
```

---

### 3. @DisplayName 활용

```java
@Test
@DisplayName("대기 중인 주문을 취소하면 상태가 CANCELLED로 변경된다")
void cancel_order_with_pending_status_changes_to_cancelled() {
    // ...
}
```

---

### 4. 예외 케이스 테스트

**필수 테스트 케이스:**
- ✅ 정상 케이스 (Happy Path)
- ✅ 예외 케이스 (Exception)
- ✅ 경계값 케이스 (Boundary)
- ✅ Null 케이스

**예시:**
```java
@Test
@DisplayName("주문 취소 - 정상 케이스")
void cancel_order_success() { }

@Test
@DisplayName("주문 취소 - 존재하지 않는 주문")
void cancel_order_not_found() {
    assertThatThrownBy(() -> orderService.cancel(999L))
        .isInstanceOf(OrderNotFoundException.class);
}

@Test
@DisplayName("주문 취소 - 이미 취소된 주문")
void cancel_order_already_cancelled() {
    assertThatThrownBy(() -> order.cancel("reason"))
        .isInstanceOf(OrderAlreadyCancelledException.class);
}

@Test
@DisplayName("주문 취소 - null reason")
void cancel_order_with_null_reason() {
    assertThatThrownBy(() -> order.cancel(null))
        .isInstanceOf(IllegalArgumentException.class);
}
```

---

### 5. AssertJ 활용

```java
// 기본 검증
assertThat(order.getStatus()).isEqualTo(OrderStatus.CANCELLED);

// 컬렉션 검증
assertThat(orders)
    .hasSize(3)
    .extracting("status")
    .containsOnly(OrderStatus.PENDING);

// 예외 검증
assertThatThrownBy(() -> order.cancel("reason"))
    .isInstanceOf(OrderAlreadyCancelledException.class)
    .hasMessage("이미 취소된 주문입니다");

// 객체 검증
assertThat(order)
    .extracting("id", "status", "totalAmount")
    .containsExactly(1L, OrderStatus.PENDING, Money.of(10000));
```

---

### 6. Mockito 활용

```java
// Mock 동작 정의
given(orderStore.findById(1L)).willReturn(Optional.of(order));

// void 메서드 Mock
willDoNothing().given(eventPublisher).publish(any());

// 예외 던지기
given(orderStore.findById(999L))
    .willThrow(new OrderNotFoundException());

// 호출 검증
verify(orderStore).save(order);
verify(eventPublisher).publish(any(OrderCancelledEvent.class));

// 호출 횟수 검증
verify(orderStore, times(1)).save(order);
verify(eventPublisher, never()).publish(any());

// 인자 캡처
ArgumentCaptor<Order> captor = ArgumentCaptor.forClass(Order.class);
verify(orderStore).save(captor.capture());
assertThat(captor.getValue().getStatus()).isEqualTo(OrderStatus.CANCELLED);
```

---

## ✅ 테스트 체크리스트

매 작업마다 다음을 확인하세요:

### Domain Layer
- [ ] Entity 생성 테스트
- [ ] 비즈니스 로직 테스트
- [ ] 예외 케이스 테스트
- [ ] Value Object 불변성 테스트

### Application Layer
- [ ] UseCase 정상 흐름 테스트
- [ ] UseCase 예외 케이스 테스트
- [ ] Mock 호출 검증
- [ ] Command/Query 유효성 테스트

### Infrastructure Layer
- [ ] Repository 저장/조회 테스트
- [ ] Query 성능 테스트 (N+1 체크)
- [ ] 트랜잭션 격리 테스트

### Interface Layer
- [ ] API 정상 응답 테스트
- [ ] API 예외 응답 테스트
- [ ] 유효성 검증 테스트
- [ ] 인증/인가 테스트
- [ ] REST Docs 문서 생성 확인 (snippets 파일)
- [ ] Constraints 컬럼 추가 확인
- [ ] 커스텀 템플릿 경로 확인 (`org/springframework/restdocs/templates/asciidoctor/`)

---

## 🚫 금지 사항

### 1. 테스트 없이 코드 작성 금지
```java
// ❌ 이렇게 하지 마세요
// 프로덕션 코드만 작성하고 "나중에 테스트 추가"
```

### 2. Thread.sleep() 사용 금지
```java
// ❌ 나쁜 예
@Test
void async_test() throws Exception {
    asyncService.process();
    Thread.sleep(1000);  // 금지!
    verify(repository).save(any());
}

// ✅ 좋은 예 - Awaitility 사용
@Test
void async_test() {
    asyncService.process();
    
    await().atMost(Duration.ofSeconds(5))
        .untilAsserted(() -> {
            verify(repository).save(any());
        });
}
```

### 3. 테스트 간 의존성 금지
```java
// ❌ 나쁜 예 - 테스트 순서에 의존
private static Order sharedOrder;

@Test
@Order(1)
void create_order() {
    sharedOrder = orderService.create(...);  // 금지!
}

@Test
@Order(2)
void cancel_order() {
    orderService.cancel(sharedOrder.getId());  // 금지!
}

// ✅ 좋은 예 - 각 테스트가 독립적
@Test
void cancel_order() {
    Order order = fixtureMonkey.giveMeOne(Order.class);
    orderService.cancel(order.getId());
}
```

### 4. 과도한 Mock 사용 금지
```java
// ❌ 나쁜 예 - 너무 많은 Mock
@Mock private Service1 service1;
@Mock private Service2 service2;
@Mock private Service3 service3;
// ... 10개 이상의 Mock

// 💡 힌트: Mock이 너무 많다면 설계를 다시 검토하세요
```

---

## 📚 참고 자료

- [JUnit 5 User Guide](https://junit.org/junit5/docs/current/user-guide/)
- [AssertJ Documentation](https://assertj.github.io/doc/)
- [Fixture Monkey Documentation](https://naver.github.io/fixture-monkey/)
- [Mockito Documentation](https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html)
- [Spring REST Docs](https://docs.spring.io/spring-restdocs/docs/current/reference/htmlsingle/)
- [Spring REST Docs - Custom Templates](https://docs.spring.io/spring-restdocs/docs/current/reference/htmlsingle/#documenting-your-api-customizing-including-snippets)

---

이 규칙을 따라 견고하고 유지보수 가능한 테스트 코드를 작성하세요! 🚀

