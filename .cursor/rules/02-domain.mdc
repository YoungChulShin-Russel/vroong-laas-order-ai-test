---
alwaysApply: true
---

# Domain Layer 규칙

## 위치
`core/domain/`

## 저장소 구조

```
core/domain/
├── order/
│   ├── Order.java              # Aggregate Root
│   ├── OrderItem.java          # Entity
│   ├── OrderStatus.java        # Enum
│   ├── Origin.java             # Value Object
│   ├── Destination.java        # Value Object
│   ├── DeliveryPolicy.java     # Value Object
│   └── required/               # ⭐ 모든 외부 의존성 Port
│       ├── OrderStore.java         # 영속성 Port (쓰기)
│       ├── OrderReader.java        # 영속성 Port (읽기)
│       ├── EmailSender.java        # 이메일 Port
│       ├── EventPublisher.java     # 이벤트 Port
│       └── PaymentGateway.java     # 결제 Port
│
├── shared/
│   ├── Money.java              # Value Object
│   ├── Address.java            # Value Object
│   ├── Contact.java            # Value Object
│   └── LatLng.java             # Value Object
│
└── service/                    # Domain Service (순수 계산만)
    └── OrderPricingService.java
```

**중요:** 
- **모든 외부 의존성 Port는 required/에 위치** (일관성)
- 순수 Domain 모델(Entity, VO)만 domain/ 직속
- required/ = Domain이 필요로 하는 모든 외부 것들
- Infrastructure에서 Adapter로 구현

## 책임
- 순수 비즈니스 규칙과 로직
- 핵심 불변식 유지
- 자기 검증
- 모든 외부 의존성 Port 인터페이스 정의 (required/)

## 반드시 해야 할 것
1. 순수 Java, Lombok만 사용 (@Getter, @Builder, @AllArgsConstructor)
2. 엔티티 내부에서 자기 검증 구현 (validate 메서드)
3. 비즈니스 계산 로직 포함
4. 팩토리 메서드 제공 (create, from 등)
5. 비즈니스 규칙 메서드 (isCancellable, isModifiable 등)
6. 비즈니스 로직 메서드 (cancel, changeAddress 등)
7. Setter 사용 금지 (@Getter만, @Setter 금지)
8. 모든 외부 의존성 Port는 required/에 위치

## 절대 하지 말 것
1. @Entity, @Table, @Column, @Id 등 JPA 어노테이션 사용 금지
2. @Repository, @Service, @Component 등 Spring 어노테이션 사용 금지
3. @Transactional 사용 금지
4. Infrastructure 의존 금지
5. Repository 구현체 의존 금지 (인터페이스만)

## Domain Entity 템플릿

```java
// core/domain/order/Order.java
@Getter
@Builder
@AllArgsConstructor(access = AccessLevel.PRIVATE)
public class Order {
    
    private Long id;
    private Long userId;
    private String orderNumber;
    private OrderStatus status;
    private List<OrderItem> items;
    private Address deliveryAddress;
    private Money totalAmount;
    private LocalDateTime createdAt;
    
    // 팩토리 메서드
    public static Order create(
        Long userId,
        List<OrderItem> items,
        Address deliveryAddress,
        Money totalAmount
    ) {
        Order order = Order.builder()
            .userId(userId)
            .orderNumber(generateOrderNumber())
            .status(OrderStatus.PENDING)
            .items(new ArrayList<>(items))
            .deliveryAddress(deliveryAddress)
            .totalAmount(totalAmount)
            .createdAt(LocalDateTime.now())
            .build();
        
        order.validate();
        return order;
    }
    
    // 비즈니스 규칙
    public boolean isCancellable() {
        return status == OrderStatus.PENDING || 
               status == OrderStatus.PAID;
    }
    
    public boolean isModifiable() {
        return status == OrderStatus.PENDING;
    }
    
    public boolean isOwnedBy(Long userId) {
        return this.userId.equals(userId);
    }
    
    // 비즈니스 로직
    public void cancel(String reason) {
        if (!isCancellable()) {
            throw new OrderNotCancellableException(
                "현재 상태(" + status + ")에서는 취소할 수 없습니다"
            );
        }
        this.status = OrderStatus.CANCELLED;
    }
    
    public void changeAddress(Address newAddress) {
        if (!isModifiable()) {
            throw new OrderNotModifiableException();
        }
        this.deliveryAddress = newAddress;
    }
    
    public void completePayment(Long paymentId) {
        if (status != OrderStatus.PENDING) {
            throw new InvalidOrderStatusException();
        }
        this.status = OrderStatus.PAID;
    }
    
    // 계산 메서드
    public Money calculateRefundAmount() {
        if (status == OrderStatus.DELIVERED) {
            return totalAmount.multiply(0.9); // 10% 수수료
        }
        return totalAmount;
    }
    
    public int getTotalQuantity() {
        return items.stream()
            .mapToInt(OrderItem::getQuantity)
            .sum();
    }
    
    public Weight getTotalWeight() {
        return items.stream()
            .map(OrderItem::getWeight)
            .reduce(Weight.ZERO, Weight::add);
    }
    
    // 자기 검증
    private void validate() {
        if (userId == null || userId <= 0) {
            throw new InvalidOrderException("유효하지 않은 사용자 ID입니다");
        }
        
        if (items == null || items.isEmpty()) {
            throw new EmptyOrderException("주문 상품이 없습니다");
        }
        
        if (deliveryAddress == null) {
            throw new InvalidOrderException("배송지는 필수입니다");
        }
        
        if (totalAmount == null || totalAmount.isNegative()) {
            throw new InvalidOrderException("유효하지 않은 주문 금액입니다");
        }
        
        // 각 OrderItem 검증
        items.forEach(OrderItem::validate);
        
        // 계산된 금액과 실제 금액 일치 검증
        Money calculatedAmount = items.stream()
            .map(OrderItem::getSubtotal)
            .reduce(Money.ZERO, Money::add);
        
        if (!totalAmount.equals(calculatedAmount)) {
            throw new OrderAmountMismatchException();
        }
    }
    
    private static String generateOrderNumber() {
        return "ORD" + System.currentTimeMillis();
    }
}
```

## Store/Reader Port 템플릿 (required/에 위치)

### OrderStore (쓰기)

```java
// core/domain/order/required/OrderStore.java
public interface OrderStore {
    
    /**
     * 주문 저장
     */
    Order save(Order order);
    
    /**
     * 주문 삭제
     */
    void delete(Order order);
}
```

### OrderReader (읽기)

```java
// core/domain/order/required/OrderReader.java
public interface OrderReader {
    
    /**
     * ID로 주문 조회
     */
    Optional<Order> findById(Long id);
    
    /**
     * ID로 주문 조회 (OrderItem 포함)
     */
    Optional<Order> findByIdWithItems(Long id);
    
    /**
     * 주문번호로 조회
     */
    Optional<Order> findByOrderNumber(String orderNumber);
    
    /**
     * 주문번호 존재 여부 확인
     */
    boolean existsByOrderNumber(String orderNumber);
    
    /**
     * 사용자 주문 목록 조회
     */
    Page<Order> findByUserId(Long userId, Pageable pageable);
    
    /**
     * 주문 검색
     */
    Page<Order> search(OrderSearchCondition condition, Pageable pageable);
}
```

**특징:**
- ✅ Domain Layer의 required/에 위치
- ✅ CQRS 패턴 적용 (Store/Reader 분리)
- ✅ 순수 Java 인터페이스 (JPA 어노테이션 없음)
- ✅ Infrastructure에서 Adapter로 구현

## Required Port 템플릿 (Domain에 위치)

```java
// core/domain/order/required/EmailSender.java
public interface EmailSender {
    void send(String to, String subject, String body);
    void sendOrderConfirmation(Order order);
}

// core/domain/order/required/EventPublisher.java
public interface EventPublisher {
    void publish(DomainEvent event);
}

// core/domain/order/required/PaymentGateway.java
public interface PaymentGateway {
    PaymentResult process(Long orderId, Money amount, PaymentMethod method);
    void refund(Long paymentId);
}
```

**특징:**
- ✅ Domain Layer에 위치 (Domain이 필요로 하는 것)
- ✅ 순수 Java 인터페이스
- ✅ Infrastructure에서 Adapter로 구현
- ✅ Domain은 구현을 모름 (DIP)

## Value Object 템플릿

```java
// core/domain/shared/Money.java
public record Money(BigDecimal value) {
    
    public static final Money ZERO = new Money(BigDecimal.ZERO);
    
    public Money {
        if (value == null) {
            throw new IllegalArgumentException("금액은 null일 수 없습니다");
        }
    }
    
    public static Money of(long amount) {
        return new Money(BigDecimal.valueOf(amount));
    }
    
    public static Money of(BigDecimal amount) {
        return new Money(amount);
    }
    
    public boolean isNegative() {
        return value.compareTo(BigDecimal.ZERO) < 0;
    }
    
    public boolean isPositive() {
        return value.compareTo(BigDecimal.ZERO) > 0;
    }
    
    public boolean isLessThan(Money other) {
        return value.compareTo(other.value) < 0;
    }
    
    public boolean isGreaterThan(Money other) {
        return value.compareTo(other.value) > 0;
    }
    
    public Money add(Money other) {
        return new Money(value.add(other.value));
    }
    
    public Money subtract(Money other) {
        return new Money(value.subtract(other.value));
    }
    
    public Money multiply(double multiplier) {
        return new Money(
            value.multiply(BigDecimal.valueOf(multiplier))
        );
    }
    
    public Money multiply(int multiplier) {
        return new Money(
            value.multiply(BigDecimal.valueOf(multiplier))
        );
    }
}

// core/domain/shared/Address.java
public record Address(
    String zipCode,
    String street,
    String detail
) {
    public Address {
        if (zipCode == null || zipCode.isBlank()) {
            throw new IllegalArgumentException("우편번호는 필수입니다");
        }
        if (street == null || street.isBlank()) {
            throw new IllegalArgumentException("주소는 필수입니다");
        }
    }
    
    public String getFullAddress() {
        return String.format("[%s] %s %s", 
            zipCode, 
            street, 
            detail != null ? detail : ""
        );
    }
}
```

## Domain Service 규칙

### 위치
`core/domain/service/`

### 책임
- 여러 Aggregate를 조합하는 순수 계산
- 상태 없는 비즈니스 정책
- 복잡한 비즈니스 규칙

### 반드시 해야 할 것
1. Domain 객체만 의존
2. 순수 계산 로직만
3. Stateless (상태 없음)

### 절대 하지 말 것
1. @Transactional 사용 금지
2. Repository 의존 금지
3. 저장/조회 작업 금지
4. 이벤트 발행 금지
5. Infrastructure 의존 금지

### Domain Service 템플릿

```java
// core/domain/service/OrderPricingService.java
@DomainService
public class OrderPricingService {
    
    private final ShippingFeePolicy shippingFeePolicy;
    
    /**
     * 주문 가격 계산 (순수 계산)
     */
    public OrderPrice calculatePrice(
        List<OrderItem> items,
        Coupon coupon,
        Address address,
        CustomerGrade customerGrade
    ) {
        // 1. 상품 금액
        Money itemsTotal = items.stream()
            .map(OrderItem::getSubtotal)
            .reduce(Money.ZERO, Money::add);
        
        // 2. 쿠폰 할인
        Money couponDiscount = coupon != null ? 
            coupon.calculateDiscount(itemsTotal) : Money.ZERO;
        
        // 3. 등급 할인
        Money gradeDiscount = calculateGradeDiscount(itemsTotal, customerGrade);
        
        Money totalDiscount = couponDiscount.add(gradeDiscount);
        
        // 4. 배송비
        Weight totalWeight = calculateTotalWeight(items);
        Money discountedAmount = itemsTotal.subtract(totalDiscount);
        Money shippingFee = shippingFeePolicy.calculate(
            discountedAmount,
            address,
            totalWeight
        );
        
        // 5. 최종 금액
        Money totalAmount = discountedAmount.add(shippingFee);
        
        return OrderPrice.builder()
            .itemsTotal(itemsTotal)
            .couponDiscount(couponDiscount)
            .gradeDiscount(gradeDiscount)
            .shippingFee(shippingFee)
            .totalAmount(totalAmount)
            .build();
    }
    
    private Money calculateGradeDiscount(Money amount, CustomerGrade grade) {
        return switch (grade) {
            case VIP -> amount.multiply(0.05);
            case GOLD -> amount.multiply(0.03);
            case SILVER -> amount.multiply(0.01);
            case BRONZE -> Money.ZERO;
        };
    }
    
    private Weight calculateTotalWeight(List<OrderItem> items) {
        return items.stream()
            .map(OrderItem::getWeight)
            .reduce(Weight.ZERO, Weight::add);
    }
    
    // 저장 없음, 조회 없음, 이벤트 없음, 트랜잭션 무관
}
```

## Domain Service vs Application Support 구분

### Domain Service (core/domain/service/)
- 순수 계산만
- Infrastructure 의존 없음

```java
@DomainService
public class OrderPricingService {
    private final ShippingFeePolicy policy;  // Domain 정책만
    
    public OrderPrice calculatePrice(...) {
        // 계산 로직만
    }
}
```

### Application Support (core/application/order/support/)
- 트랜잭션 관리
- Repository 사용
- Infrastructure 의존

```java
@Service
@RequiredArgsConstructor
public class OrderCompletionService {
    private final OrderRepository orderRepository;        // Repository OK
    private final EmailSender emailSender;                // Port OK
    private final OrderPricingService pricingService;     // Domain Service
    
    @Transactional  // 트랜잭션 OK
    public Order complete(...) {
        // 저장, 이메일 발송
    }
}
```

## Domain Exception 규칙

### 저장소 구조

```
core/
├── common/
│   └── exception/
│       ├── BaseException.java      # ⭐ 모든 커스텀 예외의 기반 클래스
│       └── ErrorCode.java          # 에러 코드 enum
│
└── domain/
    └── order/
        ├── Order.java
        └── exception/              # ⭐ Domain Exception
            ├── OrderNotFoundException.java
            ├── OrderAlreadyAssignedException.java
            ├── OrderNotCancellableException.java
            └── InvalidOrderException.java
```

### 반드시 해야 할 것 ⭐

1. **모든 커스텀 Exception은 BaseException을 상속**
2. ErrorCode를 포함하여 구조화된 에러 정보 전달
3. 명확한 예외 메시지 제공
4. 생성자 오버로딩으로 다양한 사용 케이스 지원

### BaseException 템플릿

```java
// core/common/exception/BaseException.java
@Getter
public abstract class BaseException extends RuntimeException {
  
  private final ErrorCode errorCode;
  
  protected BaseException(ErrorCode errorCode, String message) {
    super(message);
    this.errorCode = errorCode;
  }
  
  protected BaseException(ErrorCode errorCode) {
    super(errorCode.getMessage());
    this.errorCode = errorCode;
  }
  
  protected BaseException(ErrorCode errorCode, String message, Throwable cause) {
    super(message, cause);
    this.errorCode = errorCode;
  }
}
```

### Domain Exception 템플릿

```java
// core/domain/order/exception/OrderNotFoundException.java
public class OrderNotFoundException extends BaseException {
  
  public OrderNotFoundException(Long orderId) {
    super(ErrorCode.ORDER_NOT_FOUND, "주문을 찾을 수 없습니다. ID: " + orderId);
  }
  
  public OrderNotFoundException(String orderNumber) {
    super(ErrorCode.ORDER_NOT_FOUND, "주문을 찾을 수 없습니다. 주문번호: " + orderNumber);
  }
}

// core/domain/order/exception/OrderNotCancellableException.java
public class OrderNotCancellableException extends BaseException {
  
  public OrderNotCancellableException(Long orderId, OrderStatus currentStatus) {
    super(
        ErrorCode.ORDER_NOT_CANCELLABLE,
        "현재 상태(" + currentStatus + ")에서는 취소할 수 없습니다. 주문 ID: " + orderId);
  }
}
```

### ErrorCode enum

```java
// core/common/exception/ErrorCode.java
@Getter
@RequiredArgsConstructor
public enum ErrorCode {
  
  // 4xx: 클라이언트 에러
  VALIDATION_ERROR("입력값 검증에 실패했습니다"),
  INVALID_INPUT("잘못된 입력입니다"),
  
  // 비즈니스 로직 에러
  ORDER_NOT_FOUND("주문을 찾을 수 없습니다"),
  ORDER_ALREADY_ASSIGNED("이미 다른 기사님이 배정된 주문입니다"),
  ORDER_NOT_CANCELLABLE("현재 상태에서는 취소할 수 없습니다"),
  
  // 5xx: 서버 에러
  INTERNAL_SERVER_ERROR("서버 오류가 발생했습니다");
  
  private final String message;
  
  public String getCode() {
    return this.name();
  }
}
```

### Domain에서 Exception 사용

```java
// core/domain/order/Order.java
public class Order {
  
  public void cancel(String reason) {
    if (!isCancellable()) {
      throw new OrderNotCancellableException(this.id, this.status);  // ⭐ BaseException 상속
    }
    this.status = OrderStatus.CANCELLED;
  }
  
  private void validate() {
    if (items == null || items.isEmpty()) {
      throw new InvalidOrderException("주문 상품이 없습니다");  // ⭐ BaseException 상속
    }
  }
}
```

### Exception 처리 (API Layer)

```java
// api/web/common/exception/WebApiControllerAdvice.java
@RestControllerAdvice
public class WebApiControllerAdvice {
  
  @ExceptionHandler(BaseException.class)  // ⭐ BaseException으로 모든 커스텀 예외 처리
  public ResponseEntity<ProblemDetail> handleBaseException(BaseException e) {
    ProblemDetail problem = createProblemDetail(
        HttpStatus.BAD_REQUEST,
        e.getErrorCode(),  // ErrorCode 자동 연결
        e.getMessage(),
        e
    );
    return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(problem);
  }
}
```

**응답 예시:**
```json
{
  "status": 400,
  "detail": "주문을 찾을 수 없습니다. ID: 1",
  "timestamp": "2025-01-06T12:00:00Z",
  "errorCode": "ORDER_NOT_FOUND",
  "exception": "OrderNotFoundException"
}
```

## 중요 원칙
1. Domain은 순수 Java만
2. **모든 외부 의존성 Port는 required/에 위치** (일관성)
3. **모든 커스텀 Exception은 BaseException을 상속** ⭐
4. 순수 Domain 모델만 domain/ 직속
5. Domain Service는 계산만
6. 저장/조회는 Application Layer에서 Store/Reader를 통해
7. Infrastructure는 절대 의존하지 않음 (인터페이스로만 의존)
