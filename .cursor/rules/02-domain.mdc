---
alwaysApply: true
---

# Domain Layer 규칙

## 위치
`core/domain/`

## 저장소 구조

```
core/domain/
├── {aggregate}/                         # 예: order, payment, delivery
│   ├── {Aggregate}.java                 # Aggregate Root
│   ├── {Aggregate}Creator.java          # Domain Service (생성)
│   ├── {Aggregate}Reader.java           # Domain Service (조회)
│   ├── {AggregateItem}.java             # Value Object (선택)
│   ├── {Aggregate}Number.java           # Value Object
│   ├── {Aggregate}Status.java           # Enum
│   ├── {Property1}.java                 # Value Object (도메인 특화)
│   ├── {Property2}.java                 # Value Object (도메인 특화)
│   ├── command/
│   │   └── Create{Aggregate}Command.java  # Domain Command
│   ├── event/
│   │   └── {Aggregate}CreatedEvent.java   # Domain Event
│   ├── exception/
│   │   ├── {Aggregate}NotFoundException.java
│   │   └── Invalid{Aggregate}Exception.java
│   └── required/                        # ⭐ 모든 Port
│       └── {Aggregate}Repository.java   # 영속성 Port (통합)
│
├── outbox/
│   ├── OutboxEventAppender.java         # Domain Service
│   ├── OutboxEventType.java             # Enum
│   └── required/
│       └── OutboxEventClient.java       # Outbox Port
│
└── shared/
    ├── AggregateRoot.java               # 추상 클래스 (Domain Event 관리)
    ├── Money.java                       # Value Object (공통)
    ├── Weight.java                      # Value Object (공통)
    ├── Volume.java                      # Value Object (공통)
    ├── Address.java                     # Value Object (공통)
    ├── Contact.java                     # Value Object (공통)
    ├── LatLng.java                      # Value Object (공통)
    └── event/
        └── DomainEvent.java             # Domain Event 인터페이스
```

**예시:**
- Order: order/, Order.java, OrderCreator.java, OrderItem.java, Origin, Destination
- Payment: payment/, Payment.java, PaymentCreator.java, PaymentMethod, PaymentAmount
- Delivery: delivery/, Delivery.java, DeliveryCreator.java, DeliveryAddress, DeliveryDriver

**중요:** 
- **모든 Port는 required/에 위치** (일관성)
- **Domain Service는 domain/{aggregate}/ 직속** (OrderCreator, OrderReader)
- **Command는 domain/{aggregate}/command/에 위치**
- **Repository는 통합 인터페이스** (Store/Reader 분리 안 함)
- Infrastructure에서 Adapter로 구현

## 책임
- 순수 비즈니스 규칙과 로직
- 핵심 불변식 유지
- 자기 검증
- 모든 외부 의존성 Port 인터페이스 정의 (required/)
- Domain Service로 비즈니스 로직 수행

## 반드시 해야 할 것
1. Aggregate Root는 AggregateRoot 추상 클래스 상속
2. 엔티티 내부에서 자기 검증 구현
3. 비즈니스 계산 로직 포함
4. 팩토리 메서드 제공 (create, from 등)
5. Domain Service에 @Service 애노테이션 사용
6. Setter 사용 금지 (@Getter만, @Setter 금지)
7. 모든 외부 의존성 Port는 required/에 위치

## 절대 하지 말 것
1. @Entity, @Table, @Column, @Id 등 JPA 어노테이션 사용 금지
2. Infrastructure 의존 금지
3. Repository 구현체 의존 금지 (인터페이스만)

---

## AggregateRoot 추상 클래스

모든 Aggregate Root는 `AggregateRoot`를 상속받아 Domain Event를 관리합니다.

```java
// core/domain/shared/AggregateRoot.java
public abstract class AggregateRoot {

  private final List<DomainEvent> domainEvents = new ArrayList<>();

  protected void addDomainEvent(DomainEvent event) {
    this.domainEvents.add(event);
  }

  public List<DomainEvent> getDomainEvents() {
    return Collections.unmodifiableList(domainEvents);
  }

  public void clearDomainEvents() {
    this.domainEvents.clear();
  }
}
```

---

## Domain Entity 템플릿

### 일반 템플릿

```java
// core/domain/{aggregate}/{Aggregate}.java
@Getter
@ToString
public class {Aggregate} extends AggregateRoot {
    
    private final Long id;
    private final {Aggregate}Number {aggregate}Number;
    private final {Aggregate}Status status;
    private final List<{AggregateItem}> items;  // (선택)
    private final {Property1} property1;
    private final {Property2} property2;
    private final Instant createdAt;
    private final Instant completedAt;
    private final Instant cancelledAt;
    
    // 생성자 - 필수 값 검증
    public {Aggregate}(
        Long id,
        {Aggregate}Number {aggregate}Number,
        {Aggregate}Status status,
        List<{AggregateItem}> items,
        {Property1} property1,
        {Property2} property2,
        Instant createdAt,
        Instant completedAt,
        Instant cancelledAt
    ) {
        // 필수 값 검증
        if (id == null) {
            throw new IllegalArgumentException("ID는 필수입니다");
        }
        if ({aggregate}Number == null) {
            throw new IllegalArgumentException("{Aggregate} 번호는 필수입니다");
        }
        // ... 기타 검증
        
        this.id = id;
        this.{aggregate}Number = {aggregate}Number;
        this.status = status;
        this.items = items != null ? List.copyOf(items) : null;
        this.property1 = property1;
        this.property2 = property2;
        this.createdAt = createdAt;
        this.completedAt = completedAt;
        this.cancelledAt = cancelledAt;
    }
    
    // 팩토리 메서드 - 비즈니스 규칙 + Domain Event 자동 추가
    public static {Aggregate} create(
        Long id,
        {Aggregate}Number {aggregate}Number,
        List<{AggregateItem}> items,
        {Property1} property1,
        {Property2} property2
    ) {
        {Aggregate} {aggregate} = new {Aggregate}(
            id,
            {aggregate}Number,
            {Aggregate}Status.CREATED,
            items,
            property1,
            property2,
            Instant.now(),
            null,
            null
        );
        
        // Domain Event 자동 추가
        {aggregate}.addDomainEvent({Aggregate}CreatedEvent.from({aggregate}));
        
        return {aggregate};
    }
}
```

### 실제 예시 (Order)

```java
// core/domain/order/Order.java
@Getter
@ToString
public class Order extends AggregateRoot {
    
    private final Long id;
    private final OrderNumber orderNumber;
    private final OrderStatus status;
    private final List<OrderItem> items;
    private final Origin origin;
    private final Destination destination;
    private final DeliveryPolicy deliveryPolicy;
    private final Instant orderedAt;
    private final Instant deliveredAt;
    private final Instant cancelledAt;
    
    // 생성자 - 필수 값 검증
    public Order(
        Long id,
        OrderNumber orderNumber,
        OrderStatus status,
        List<OrderItem> items,
        Origin origin,
        Destination destination,
        DeliveryPolicy deliveryPolicy,
        Instant orderedAt,
        Instant deliveredAt,
        Instant cancelledAt
    ) {
        // 필수 값 검증
        if (id == null) {
            throw new IllegalArgumentException("ID는 필수입니다");
        }
        if (orderNumber == null) {
            throw new IllegalArgumentException("주문번호는 필수입니다");
        }
        // ... 기타 검증
        
        this.id = id;
        this.orderNumber = orderNumber;
        this.status = status;
        this.items = List.copyOf(items);
        this.origin = origin;
        this.destination = destination;
        this.deliveryPolicy = deliveryPolicy;
        this.orderedAt = orderedAt;
        this.deliveredAt = deliveredAt;
        this.cancelledAt = cancelledAt;
    }
    
    // 팩토리 메서드 - 비즈니스 규칙 + Domain Event 자동 추가
    public static Order create(
        Long id,
        OrderNumber orderNumber,
        List<OrderItem> items,
        Origin origin,
        Destination destination,
        DeliveryPolicy deliveryPolicy
    ) {
        Order order = new Order(
            id,
            orderNumber,
            OrderStatus.CREATED,
            items,
            origin,
            destination,
            deliveryPolicy,
            Instant.now(),
            null,
            null
        );
        
        // Domain Event 자동 추가
        order.addDomainEvent(OrderCreatedEvent.from(order));
        
        return order;
    }
}
```

---

## Domain Service 템플릿

### 일반 템플릿

#### {Aggregate}Creator (생성 책임)

```java
// core/domain/{aggregate}/{Aggregate}Creator.java
@Service
@RequiredArgsConstructor
public class {Aggregate}Creator {

  private final {Aggregate}NumberGenerator {aggregate}NumberGenerator;
  private final {Aggregate}Repository {aggregate}Repository;
  private final OutboxEventAppender outboxEventAppender;

  @Transactional
  public {Aggregate} create(Create{Aggregate}Command command) {
    // 1. {Aggregate} 번호 생성
    {Aggregate}Number {aggregate}Number = {aggregate}NumberGenerator.generate();

    // 2. {Aggregate} 저장 ({Aggregate}.create()가 내부에서 호출되어 도메인 이벤트 자동 추가)
    {Aggregate} {aggregate} =
        {aggregate}Repository.store(
            {aggregate}Number,
            command.items(),
            command.property1(),
            command.property2());

    // 3. 도메인 이벤트 발행
    outboxEventAppender.append(OutboxEventType.{AGGREGATE}_CREATED, {aggregate});

    return {aggregate};
  }
}
```

#### {Aggregate}Reader (조회 책임)

```java
// core/domain/{aggregate}/{Aggregate}Reader.java
@Service
@RequiredArgsConstructor
public class {Aggregate}Reader {

  private final {Aggregate}Repository {aggregate}Repository;

  @ReadOnlyTransactional
  public {Aggregate} get{Aggregate}ById(Long id) {
    return {aggregate}Repository
        .findById(id)
        .orElseThrow(() -> new {Aggregate}NotFoundException(id));
  }

  @ReadOnlyTransactional
  public {Aggregate} get{Aggregate}By{Aggregate}Number({Aggregate}Number {aggregate}Number) {
    return {aggregate}Repository
        .findBy{Aggregate}Number({aggregate}Number)
        .orElseThrow(() -> new {Aggregate}NotFoundException({aggregate}Number));
  }
}
```

### 실제 예시 (Order)

#### OrderCreator

```java
// core/domain/order/OrderCreator.java
@Service
@RequiredArgsConstructor
public class OrderCreator {

  private final OrderNumberGenerator orderNumberGenerator;
  private final OrderRepository orderRepository;
  private final OutboxEventAppender outboxEventAppender;

  @Transactional
  public Order create(CreateOrderCommand command) {
    // 1. 주문번호 생성
    OrderNumber orderNumber = orderNumberGenerator.generate();

    // 2. Order 저장 (Order.create()가 내부에서 호출되어 도메인 이벤트 자동 추가)
    Order order =
        orderRepository.store(
            orderNumber,
            command.items(),
            command.origin(),
            command.destination(),
            command.deliveryPolicy());

    // 3. 도메인 이벤트 발행
    outboxEventAppender.append(OutboxEventType.ORDER_CREATED, order);

    return order;
  }
}
```

#### OrderReader

```java
// core/domain/order/OrderReader.java
@Service
@RequiredArgsConstructor
public class OrderReader {

  private final OrderRepository orderRepository;

  @ReadOnlyTransactional
  public Order getOrderById(Long id) {
    return orderRepository
        .findById(id)
        .orElseThrow(() -> new OrderNotFoundException(id));
  }

  @ReadOnlyTransactional
  public Order getOrderByOrderNumber(OrderNumber orderNumber) {
    return orderRepository
        .findByOrderNumber(orderNumber)
        .orElseThrow(() -> new OrderNotFoundException(orderNumber));
  }
}
```

**특징:**
- ✅ @Service 애노테이션 사용
- ✅ 책임 분리 (Creator: 생성, Reader: 조회)
- ✅ 비즈니스 로직은 여기서 수행
- ✅ Repository Port(인터페이스)만 의존

---

## OrderRepository Port 템플릿 (통합)

**중요:** Store/Reader 분리하지 않고 **하나의 Repository로 통합**

```java
// core/domain/order/required/OrderRepository.java
public interface OrderRepository {

  /**
   * Order 생성 및 저장
   *
   * <p>Order Entity를 생성하고 저장한 후, 완전한 Order 모델(id 포함)을 반환합니다.
   *
   * @param orderNumber 주문번호
   * @param items 주문 아이템 목록
   * @param origin 출발지
   * @param destination 도착지
   * @param deliveryPolicy 배송 정책
   * @return 저장된 Order (id 할당됨)
   */
  Order store(
      OrderNumber orderNumber,
      List<OrderItem> items,
      Origin origin,
      Destination destination,
      DeliveryPolicy deliveryPolicy);

  /**
   * ID로 Order 조회
   */
  Optional<Order> findById(Long id);

  /**
   * 주문번호로 Order 조회
   */
  Optional<Order> findByOrderNumber(OrderNumber orderNumber);

  /**
   * 주문번호 존재 여부 확인
   */
  boolean existsByOrderNumber(OrderNumber orderNumber);
}
```

**특징:**
- ✅ Domain Layer의 required/에 위치
- ✅ **Store/Reader 분리하지 않음** (통합 인터페이스)
- ✅ 순수 Java 인터페이스 (JPA 어노테이션 없음)
- ✅ Infrastructure에서 Adapter로 구현

---

## Outbox Pattern

### OutboxEventAppender (Domain Service)

```java
// core/domain/outbox/OutboxEventAppender.java
@Service
@RequiredArgsConstructor
public class OutboxEventAppender {

  private final OutboxEventClient outboxEventClient;

  /**
   * AggregateRoot를 Outbox에 저장
   */
  public void append(OutboxEventType type, AggregateRoot aggregateRoot) {
    outboxEventClient.save(type, aggregateRoot);
  }
}
```

### OutboxEventClient Port

```java
// core/domain/outbox/required/OutboxEventClient.java
public interface OutboxEventClient {

  /**
   * AggregateRoot를 Outbox에 저장
   *
   * @param type Outbox Event Type (ORDER_CREATED, ORDER_CANCELLED 등)
   * @param aggregateRoot AggregateRoot (Order, Payment 등)
   */
  void save(OutboxEventType type, AggregateRoot aggregateRoot);
}
```

### OutboxEventType

```java
// core/domain/outbox/OutboxEventType.java
public enum OutboxEventType {
  /** 주문 생성 이벤트 */
  ORDER_CREATED,
}
```

**Outbox 패턴 흐름:**
```
OrderCreator (Domain Service)
  1. orderRepository.store(order)        → Order 저장 (DB)
  2. outboxEventAppender.append(order)   → Outbox 저장 (DB, 같은 트랜잭션)
     → outboxEventClient.save()          → Infrastructure Layer
       → KafkaOutboxEventMapper.map()    → Order → KafkaEvent 변환
       → outboxEventService.registerEvent() → Outbox 라이브러리 호출
```

---

## Domain Command 템플릿

Command는 **Domain Layer**에 위치합니다.

```java
// core/domain/order/command/CreateOrderCommand.java
@Builder
public record CreateOrderCommand(
    List<OrderItem> items,
    Origin origin,
    Destination destination,
    DeliveryPolicy deliveryPolicy
) {
    // 필수 값 검증
    public CreateOrderCommand {
        if (items == null || items.isEmpty()) {
            throw new IllegalArgumentException("주문 아이템은 최소 1개 이상이어야 합니다");
        }
        if (origin == null) {
            throw new IllegalArgumentException("출발지는 필수입니다");
        }
        if (destination == null) {
            throw new IllegalArgumentException("도착지는 필수입니다");
        }
        if (deliveryPolicy == null) {
            throw new IllegalArgumentException("배송 정책은 필수입니다");
        }
    }
}
```

**특징:**
- ✅ Domain Layer에 위치 (domain/{aggregate}/command/)
- ✅ record 사용 (불변성)
- ✅ 필수 값 검증만 (비즈니스 규칙은 Domain Service에서)

---

## Domain Event 템플릿

### DomainEvent 인터페이스

```java
// core/domain/shared/event/DomainEvent.java
public interface DomainEvent {
  Instant occurredAt();
  
  default String eventType() {
    return this.getClass().getSimpleName();
  }
  
  String aggregateType();
  String aggregateId();
}
```

### OrderCreatedEvent

```java
// core/domain/order/event/OrderCreatedEvent.java
public record OrderCreatedEvent(
    Long orderId,
    OrderNumber orderNumber,
    OrderStatus status,
    List<OrderItem> items,
    Origin origin,
    Destination destination,
    DeliveryPolicy deliveryPolicy,
    Instant orderedAt,
    Instant occurredAt
) implements DomainEvent {
  
  public static OrderCreatedEvent from(Order order) {
    return new OrderCreatedEvent(
        order.getId(),
        order.getOrderNumber(),
        order.getStatus(),
        List.copyOf(order.getItems()),
        order.getOrigin(),
        order.getDestination(),
        order.getDeliveryPolicy(),
        order.getOrderedAt(),
        Instant.now());
  }

  @Override
  public String aggregateType() {
    return "Order";
  }

  @Override
  public String aggregateId() {
    return String.valueOf(orderId);
  }
}
```

---

## Value Object 템플릿

```java
// core/domain/shared/Money.java
public record Money(BigDecimal amount) {
    
    public static final Money ZERO = new Money(BigDecimal.ZERO);
    
    public Money {
        if (amount == null) {
            throw new IllegalArgumentException("금액은 null일 수 없습니다");
        }
    }
    
    public static Money of(long amount) {
        return new Money(BigDecimal.valueOf(amount));
    }
    
    public boolean isNegative() {
        return amount.compareTo(BigDecimal.ZERO) < 0;
    }
    
    public Money add(Money other) {
        return new Money(amount.add(other.amount));
    }
    
    public Money multiply(int multiplier) {
        return new Money(amount.multiply(BigDecimal.valueOf(multiplier)));
    }
}

// core/domain/shared/Address.java
public record Address(
    String jibnunAddress,
    String roadAddress,
    String detailAddress
) {
    public Address {
        if (jibnunAddress == null || jibnunAddress.isBlank()) {
            throw new IllegalArgumentException("지번 주소는 필수입니다");
        }
        if (roadAddress == null || roadAddress.isBlank()) {
            throw new IllegalArgumentException("도로명 주소는 필수입니다");
        }
    }
}
```

---

## Domain Exception 규칙

### 저장소 구조

```
core/
├── common/
│   └── exception/
│       ├── BaseException.java      # ⭐ 모든 커스텀 예외의 기반 클래스
│       └── ErrorCode.java          # 에러 코드 enum
│
└── domain/
    └── order/
        └── exception/              # Domain Exception
            ├── OrderNotFoundException.java
            ├── OrderAlreadyAssignedException.java
            └── InvalidOrderException.java
```

### BaseException 템플릿

```java
// core/common/exception/BaseException.java
@Getter
public abstract class BaseException extends RuntimeException {
  
  private final ErrorCode errorCode;
  
  protected BaseException(ErrorCode errorCode, String message) {
    super(message);
    this.errorCode = errorCode;
  }
  
  protected BaseException(ErrorCode errorCode) {
    super(errorCode.getMessage());
    this.errorCode = errorCode;
  }
}
```

### Domain Exception 템플릿

```java
// core/domain/order/exception/OrderNotFoundException.java
public class OrderNotFoundException extends BaseException {
  
  public OrderNotFoundException(Long orderId) {
    super(ErrorCode.ORDER_NOT_FOUND, "주문을 찾을 수 없습니다. ID: " + orderId);
  }
  
  public OrderNotFoundException(OrderNumber orderNumber) {
    super(ErrorCode.ORDER_NOT_FOUND, "주문을 찾을 수 없습니다. 주문번호: " + orderNumber.value());
  }
}
```

---

## 중요 원칙
1. Domain은 순수 비즈니스 로직만
2. **모든 Port는 required/에 위치** (일관성)
3. **Repository는 통합 인터페이스** (Store/Reader 분리 안 함)
4. **Domain Service는 domain/{aggregate}/ 직속**
5. **Command는 domain/{aggregate}/command/에 위치**
6. **모든 커스텀 Exception은 BaseException을 상속**
7. Domain Service는 @Service 애노테이션 사용
8. Aggregate Root는 AggregateRoot 상속으로 Domain Event 관리
9. Infrastructure는 절대 의존하지 않음 (인터페이스로만 의존)
