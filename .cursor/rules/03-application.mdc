---
alwaysApply: true
---

# Application Layer 규칙

## 위치
`core/application/`

## 저장소 구조

```
core/application/
└── order/
    ├── usecase/
    │   ├── CreateOrderUseCase.java
    │   └── CancelOrderUseCase.java
    ├── command/
    │   ├── CreateOrderCommand.java
    │   └── CancelOrderCommand.java
    ├── query/
    │   └── GetOrderQuery.java
    └── support/                         # 선택 사항
        └── OrderRetriever.java
```

**중요:**
- **모든 Port는 Domain Layer의 required/에 위치** 
  - `core/domain/order/required/OrderStore.java` (영속성 쓰기)
  - `core/domain/order/required/OrderReader.java` (영속성 읽기)
  - `core/domain/order/required/EmailSender.java` (이메일)
  - `core/domain/order/required/EventPublisher.java` (이벤트)
- UseCase는 Domain의 Port만 의존

## 책임
- Use Case 실행 및 흐름 조정
- Domain 로직 호출 (직접 구현 금지)
- 트랜잭션 관리

## 반드시 해야 할 것
1. UseCase별 파일 분리 (1 UseCase = 1 execute())
2. Domain의 required/ Port만 의존 (Store, Reader, 기타 Port)
3. Command/Query로 입력 받기
4. Domain 로직 호출만 (직접 구현 금지)

## 절대 하지 말 것
1. 비즈니스 로직 직접 구현 금지
2. JPA, Infrastructure 직접 의존 금지
3. Port 인터페이스를 Application에 정의하지 말 것 (Domain required/에 위치)

---

## 트랜잭션 전략

### 원칙 1: 기본 - Repository Adapter에 @Transactional

**적용 조건:**
- 단일 Aggregate만 수정
- 가장 일반적인 패턴

**예시:**
```java
// Infrastructure - Repository Adapter
@Repository
@RequiredArgsConstructor
public class OrderRepositoryAdapter implements OrderRepository {
    
    private final OrderJpaRepository jpaRepository;
    
    @Transactional  // ⭐ Adapter에서 트랜잭션
    @Override
    public Order save(Order order) {
        OrderJpaEntity entity = OrderJpaEntity.from(order);
        OrderJpaEntity saved = jpaRepository.save(entity);
        return saved.toDomain();
    }
}

// UseCase - 트랜잭션 없음
@UseCase
@RequiredArgsConstructor
public class CancelOrderUseCase {
    private final OrderRepository orderRepository;
    
    public void execute(CancelOrderCommand command) {
        Order order = orderRepository.findById(command.orderId())
            .orElseThrow();
        
        order.cancel(command.reason());
        orderRepository.save(order);  // 여기서 짧은 트랜잭션
    }
}
```

### 원칙 2: 여러 Aggregate 수정 - TransactionTemplate

**적용 조건:**
- 여러 Aggregate를 동시에 수정
- 원자성이 필요한 비즈니스 로직

**예시:**
```java
@UseCase
@RequiredArgsConstructor
public class CreateOrderUseCase {
    
    private final TransactionTemplate transactionTemplate;
    private final OrderRepository orderRepository;
    private final CouponRepository couponRepository;
    
    public Order execute(CreateOrderCommand command) {
        return transactionTemplate.execute(status -> {
            // 1. Coupon 사용
            Coupon coupon = couponRepository.findById(command.couponId())
                .orElseThrow();
            coupon.use();
            couponRepository.save(coupon);
            
            // 2. Order 생성
            Order order = Order.create(...);
            return orderRepository.save(order);
        });
    }
}
```

### 원칙 3: 외부 API 호출 사이 - TransactionTemplate 분리

**외부 API 호출이 트랜잭션 사이에 끼어있는 경우**

```java
@UseCase
@RequiredArgsConstructor
public class ProcessOrderPaymentUseCase implements UseCase<ProcessPaymentCommand> {
    
    private final TransactionTemplate transactionTemplate;
    private final OrderRepository orderRepository;
    private final PaymentGateway paymentGateway;  // 외부 API
    
    public void execute(ProcessPaymentCommand command) {
        
        // ===== 트랜잭션 1: 주문 조회 및 검증 =====
        Order order = transactionTemplate.execute(status -> {
            Order o = orderRepository.findById(command.orderId()).orElseThrow();
            
            if (!o.isPayable()) {
                throw new OrderNotPayableException();
            }
            
            return o;
        });
        
        // ===== 외부 API (트랜잭션 밖) =====
        PaymentResult payment = paymentGateway.process(order.getId(), order.getTotalAmount());
        
        // ===== 트랜잭션 2: 결제 완료 처리 =====
        transactionTemplate.executeWithoutResult(status -> {
            Order o = orderRepository.findById(order.getId()).orElseThrow();
            o.completePayment(payment);
            orderRepository.save(o);
        });
    }
}
```

**사용 시기:**
- ✅ 외부 API 호출이 DB 작업 사이에 있는 경우
- ✅ 외부 API 응답을 받아서 DB에 반영해야 하는 경우

**트랜잭션 흐름:**
```
TX1: 주문 조회/검증 (0.01초) → 커밋
  ↓
외부 API: 결제 처리 (3초) - DB 커넥션 점유 안 함
  ↓
TX2: 주문 완료 처리 (0.01초) → 커밋

총 DB 커넥션 점유: 0.02초 (vs 3.02초)
```

## Use Case 템플릿

### Command UseCase (반환값 있음)

```java
// core/application/order/usecase/command/CreateOrderUseCase.java
@UseCase
@RequiredArgsConstructor
public class CreateOrderUseCase implements UseCase<CreateOrderCommand> {
    
    private final OrderRepository orderRepository;
    private final EmailSender emailSender;
    
    @Transactional
    public Order execute(CreateOrderCommand command) {
        
        // Repository로 중복 체크
        boolean exists = orderRepository.existsByOrderNumber(command.orderNumber());
        if (exists) {
            throw new DuplicateOrderNumberException();
        }
        
        // Order 생성
        Order order = Order.create(
            command.userId(),
            command.items(),
            command.deliveryAddress(),
            command.totalAmount()
        );
        
        // Repository로 저장
        Order saved = orderRepository.save(order);
        
        // 기술적 요구사항
        emailSender.sendOrderConfirmation(saved);
        
        return saved;
    }
}
```

### Command UseCase (반환값 없음)

```java
// core/application/order/usecase/command/CancelOrderUseCase.java
@UseCase
@RequiredArgsConstructor
public class CancelOrderUseCase implements UseCase<CancelOrderCommand> {
    
    private final OrderRepository orderRepository;
    private final EventPublisher eventPublisher;
    
    @Transactional
    public void execute(CancelOrderCommand command) {
        Order order = orderRepository.findById(command.orderId())
            .orElseThrow();
        
        // 권한 체크
        if (!order.isOwnedBy(command.userId())) {
            throw new OrderAccessDeniedException();
        }
        
        order.cancel(command.reason());
        
        orderRepository.save(order);
        
        eventPublisher.publish(OrderCancelledEvent.from(order));
    }
}
```

### Query UseCase

```java
// core/application/order/usecase/query/GetMyOrdersUseCase.java
@UseCase
@RequiredArgsConstructor
public class GetMyOrdersUseCase implements UseCase<GetMyOrdersQuery> {
    
    private final OrderQueryRepository orderQueryRepository;  // 복잡한 조회용
    
    @Transactional(readOnly = true)
    public Page<OrderSummary> execute(GetMyOrdersQuery query) {
        Page<Order> orders = orderQueryRepository.findByUserId(
            query.userId(),
            query.pageable()
        );
        
        return orders.map(OrderSummary::from);
    }
}

// Note: OrderQueryRepository도 Domain Layer에 위치
// core/domain/order/OrderQueryRepository.java
public interface OrderQueryRepository {
    Page<Order> findByUserId(Long userId, Pageable pageable);
    Page<Order> search(OrderSearchCondition condition, Pageable pageable);
}
```

## Application Support 규칙 (선택 사항)

### 위치
`core/application/*/support/`

**중요: domain/service/가 아님!**

### 책임
- UseCase의 반복되는 조회/검증 로직 제거
- **비즈니스 로직 포함 금지**
- **트랜잭션 관리는 UseCase에서**

### 반드시 해야 할 것
1. 조회 및 검증만 수행
2. Store/Reader 의존 가능
3. 간단한 헬퍼 메서드만

### 절대 하지 말 것
1. **@Transactional 사용 금지** (UseCase에서 관리)
2. **비즈니스 로직 작성 금지**
3. **복잡한 흐름 제어 금지**

### Application Support 템플릿

#### Retriever (조회 헬퍼) - 권장

```java
// core/application/order/support/OrderRetriever.java
@Component
@RequiredArgsConstructor
public class OrderRetriever {
    
    private final OrderRepository orderRepository;
    
    public Order getOrder(Long orderId) {
        return orderRepository.findByIdWithItems(orderId)
            .orElseThrow(() -> new OrderNotFoundException(orderId));
    }
    
    public Order getOrderWithOwnershipCheck(Long orderId, Long userId) {
        Order order = getOrder(orderId);
        
        if (!order.isOwnedBy(userId)) {
            throw new OrderAccessDeniedException(
                "해당 주문에 접근할 권한이 없습니다"
            );
        }
        
        return order;
    }
}
```

**사용 예시:**
```java
@UseCase
@RequiredArgsConstructor
public class CancelOrderUseCase {
    
    private final OrderRetriever orderRetriever;  // ✅ 조회 헬퍼
    private final OrderRepository orderRepository;
    
    @Transactional  // ✅ UseCase에서 트랜잭션
    public void execute(CancelOrderCommand command) {
        // Retriever로 조회 및 권한 체크
        Order order = orderRetriever.getOrderWithOwnershipCheck(
            command.orderId(),
            command.userId()
        );
        
        // 비즈니스 로직
        order.cancel(command.reason());
        
        // 저장
        orderRepository.save(order);
    }
}
```

## Command/Query 설계

### Command 기본 템플릿

```java
// core/application/order/usecase/command/CreateOrderCommand.java
@Builder
public record CreateOrderCommand(
    Long userId,
    List<OrderItemCommand> items,
    String deliveryAddress,
    Long couponId
) {
    // 생성 시점 검증
    public CreateOrderCommand {
        if (userId == null || userId <= 0) {
            throw new IllegalArgumentException("유효하지 않은 사용자 ID입니다");
        }
        
        if (items == null || items.isEmpty()) {
            throw new IllegalArgumentException("주문 상품이 없습니다");
        }
        
        if (deliveryAddress == null || deliveryAddress.isBlank()) {
            throw new IllegalArgumentException("배송지가 없습니다");
        }
        
        // 중복 상품 체크
        long distinctCount = items.stream()
            .map(OrderItemCommand::productId)
            .distinct()
            .count();
        
        if (distinctCount != items.size()) {
            throw new IllegalArgumentException("중복된 상품이 있습니다");
        }
    }
    
    public record OrderItemCommand(
        Long productId,
        int quantity
    ) {
        public OrderItemCommand {
            if (productId == null || productId <= 0) {
                throw new IllegalArgumentException("유효하지 않은 상품 ID입니다");
            }
            if (quantity < 1 || quantity > 100) {
                throw new IllegalArgumentException("수량은 1~100 사이여야 합니다");
            }
        }
    }
}
```

### 상황별 입력값이 다른 경우

#### Command에 Optional 필드 + 타입 구분

```java
// core/application/order/usecase/command/CancelOrderCommand.java
@Builder
public record CancelOrderCommand(
    // 공통 필드
    Long orderId,
    String reason,
    
    // 타입 구분
    CancelType cancelType,  // CUSTOMER, ADMIN, SYSTEM
    
    // Optional 필드 (타입별로 필요)
    Long userId,        // CUSTOMER만
    String adminMemo,   // ADMIN만
    Long adminId,       // ADMIN만
    String systemCode   // SYSTEM만
) {
    // 타입별 검증
    public CancelOrderCommand {
        if (cancelType == null) {
            throw new IllegalArgumentException("취소 타입은 필수입니다");
        }
        
        switch (cancelType) {
            case CUSTOMER -> {
                if (userId == null) {
                    throw new IllegalArgumentException("고객 ID는 필수입니다");
                }
            }
            case ADMIN -> {
                if (adminId == null || adminMemo == null) {
                    throw new IllegalArgumentException("관리자 정보는 필수입니다");
                }
            }
            case SYSTEM -> {
                if (systemCode == null) {
                    throw new IllegalArgumentException("시스템 코드는 필수입니다");
                }
            }
        }
    }
}
```

#### UseCase에서 직접 처리

```java
@UseCase
@RequiredArgsConstructor
public class CancelOrderUseCase implements UseCase<CancelOrderCommand> {
    
    private final OrderRetriever orderRetriever;
    private final OrderRepository orderRepository;
    private final PaymentGateway paymentGateway;
    private final EventPublisher eventPublisher;
    
    @Transactional
    public void execute(CancelOrderCommand command) {
        
        // 1. 타입별 조회
        Order order = retrieveOrder(command);
        
        // 2. 타입별 취소 처리
        processCancellation(order, command);
        
        // 3. 저장 및 이벤트
        orderRepository.save(order);
        eventPublisher.publish(OrderCancelledEvent.from(order, command.cancelType()));
    }
    
    private Order retrieveOrder(CancelOrderCommand command) {
        return switch (command.cancelType()) {
            case CUSTOMER -> orderRetriever.getOrderWithOwnershipCheck(
                command.orderId(),
                command.userId()
            );
            case ADMIN, SYSTEM -> orderRetriever.getOrder(command.orderId());
        };
    }
    
    private void processCancellation(Order order, CancelOrderCommand command) {
        switch (command.cancelType()) {
            case CUSTOMER -> order.cancel(command.reason());
            case ADMIN -> {
                order.cancelByAdmin(command.reason(), command.adminMemo());
                if (order.isPaid()) {
                    paymentGateway.refund(order.getPaymentId());
                }
            }
            case SYSTEM -> order.cancelBySystem(command.systemCode(), command.reason());
        }
    }
}
```

## UseCase에서 Domain Port 사용

**중요:** 
- **모든 Port는 Domain Layer의 required/에 위치**
  - `core/domain/order/required/OrderStore.java`
  - `core/domain/order/required/OrderReader.java`
  - `core/domain/order/required/EmailSender.java`
  - `core/domain/order/required/EventPublisher.java`

### UseCase 예시

```java
@UseCase
@RequiredArgsConstructor
public class CreateOrderUseCase {
    
    // 모든 Port는 Domain required/에서 가져옴
    private final OrderStore orderStore;                     // Domain Port
    private final OrderReader orderReader;                   // Domain Port
    private final EmailSender emailSender;                   // Domain Port
    private final EventPublisher eventPublisher;             // Domain Port
    
    @Transactional
    public Order execute(CreateOrderCommand command) {
        // 1. 중복 체크 (Reader)
        boolean exists = orderReader.existsByOrderNumber(command.orderNumber());
        if (exists) {
            throw new DuplicateOrderNumberException();
        }
        
        // 2. Domain으로 주문 생성
        Order order = Order.create(...);
        
        // 3. Store로 저장
        Order saved = orderStore.save(order);
        
        // 4. Required Port 사용
        emailSender.sendOrderConfirmation(saved);
        eventPublisher.publish(new OrderCreatedEvent(saved));
        
        return saved;
    }
}
```

### 규칙
- ✅ 모든 Port는 Domain required/에 위치
- ✅ UseCase는 Domain의 Port(인터페이스)만 의존
- ✅ Infrastructure에서 모든 Port를 Adapter로 구현

## 중요 원칙

### 1. UseCase 설계
- 하나의 UseCase = 하나의 파일 = 하나의 execute()
- UseCase는 Port(인터페이스)만 의존
- 비즈니스 로직은 Domain에, UseCase는 흐름 제어만

### 2. 트랜잭션 전략
**기본: Repository Adapter에 @Transactional**
- 단일 Aggregate 수정
- UseCase는 트랜잭션 없음
- 짧은 트랜잭션

**여러 Aggregate 수정: TransactionTemplate**
- 여러 Aggregate를 하나의 트랜잭션으로
- UseCase에서 명시적 제어

**외부 API 사이: TransactionTemplate 분리**
- 트랜잭션을 여러 개로 쪼개기
- DB 커넥션 최소 점유

### 3. Store/Reader 분리 (CQRS)
- **OrderStore**: 쓰기 작업 (save, delete)
- **OrderReader**: 읽기 작업 (find, search, exists)
- 트랜잭션 최적화 (readOnly = true)

### 4. Support Service
- 조회/검증 헬퍼만
- 트랜잭션 관리 금지
- 비즈니스 로직 금지
</artifact>

---