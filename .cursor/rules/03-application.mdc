---
alwaysApply: true
---

# Application Layer 규칙

## 위치
`core/application/`

## 저장소 구조

```
core/application/{aggregate}/                # 예: order, payment, delivery
└── {Aggregate}Facade.java                   # Facade (흐름 조정)
```

**예시:**
- Order: application/order/OrderFacade.java
- Payment: application/payment/PaymentFacade.java
- Delivery: application/delivery/DeliveryFacade.java

**중요:**
- **Facade Pattern 사용** (UseCase 대신)
- **Domain Service만 호출** (비즈니스 로직은 Domain에서)
- **Command는 Domain Layer에 위치** (application에 없음)

## 책임
- Facade로 흐름 조정
- Domain Service 호출
- 트랜잭션 관리 (필요 시)

## 반드시 해야 할 것
1. @Facade 애노테이션 사용
2. Domain Service만 의존
3. 비즈니스 로직은 절대 직접 구현 금지
4. 간단한 흐름 조정만

## 절대 하지 말 것
1. 비즈니스 로직 직접 구현 금지
2. JPA, Infrastructure 직접 의존 금지
3. Repository 직접 호출 금지 (Domain Service를 통해서만)
4. 복잡한 로직 작성 금지

---

## Facade 패턴

### 아키텍처

```
Controller (Interface Layer)
  → Facade (Application Layer) - 흐름만 조정
    → Domain Service (Domain Layer) - 비즈니스 로직 수행
      → Repository (Port) - 영속성
        → Adapter (Infrastructure Layer) - 기술 구현
```

**특징:**
- ✅ Facade는 흐름만 조정 (비즈니스 로직 없음)
- ✅ Domain Service가 실제 비즈니스 로직 수행
- ✅ 트랜잭션은 Domain Service에서 관리

---

## Facade 템플릿

### 일반 템플릿

```java
// core/application/{aggregate}/{Aggregate}Facade.java
@Facade
@RequiredArgsConstructor
public class {Aggregate}Facade {

  private final {Aggregate}Creator {aggregate}Creator;
  private final {Aggregate}Reader {aggregate}Reader;

  /**
   * {Aggregate} 생성
   *
   * <p>{Aggregate}Creator Domain Service를 호출하여 생성합니다.
   *
   * @param command 생성 Command (Domain Layer에 위치)
   * @return 생성된 {Aggregate}
   */
  public {Aggregate} create{Aggregate}(Create{Aggregate}Command command) {
    return {aggregate}Creator.create(command);
  }

  /**
   * {Aggregate} 조회 (ID)
   *
   * @param id {Aggregate} ID
   * @return {Aggregate}
   */
  public {Aggregate} get{Aggregate}ById(Long id) {
    return {aggregate}Reader.get{Aggregate}ById(id);
  }

  /**
   * {Aggregate} 조회 ({Aggregate}번호)
   *
   * @param {aggregate}Number {Aggregate} 번호
   * @return {Aggregate}
   */
  public {Aggregate} get{Aggregate}By{Aggregate}Number({Aggregate}Number {aggregate}Number) {
    return {aggregate}Reader.get{Aggregate}By{Aggregate}Number({aggregate}Number);
  }
}
```

### 실제 예시 (Order)

```java
// core/application/order/OrderFacade.java
@Facade
@RequiredArgsConstructor
public class OrderFacade {

  private final OrderCreator orderCreator;
  private final OrderReader orderReader;

  /**
   * 주문 생성
   *
   * <p>OrderCreator Domain Service를 호출하여 주문을 생성합니다.
   *
   * @param command 주문 생성 Command (Domain Layer에 위치)
   * @return 생성된 Order
   */
  public Order createOrder(CreateOrderCommand command) {
    return orderCreator.create(command);
  }

  /**
   * 주문 조회 (ID)
   *
   * @param orderId 주문 ID
   * @return Order
   */
  public Order getOrderById(Long orderId) {
    return orderReader.getOrderById(orderId);
  }

  /**
   * 주문 조회 (주문번호)
   *
   * @param orderNumber 주문번호
   * @return Order
   */
  public Order getOrderByOrderNumber(OrderNumber orderNumber) {
    return orderReader.getOrderByOrderNumber(orderNumber);
  }
}
```

**특징:**
- ✅ @Facade 애노테이션
- ✅ Domain Service만 호출
- ✅ 비즈니스 로직 없음 (단순 위임)
- ✅ Command는 Domain Layer에서 가져옴

---

## @Facade 애노테이션

```java
// core/application/common/annotation/Facade.java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Service
public @interface Facade {
}
```

**특징:**
- ✅ Spring @Service를 포함
- ✅ 의미론적으로 Facade임을 명시
- ✅ Component Scan에서 자동 등록

---

## 트랜잭션 전략

### 기본: Domain Service에서 @Transactional

**Facade는 트랜잭션 관리 안 함**

```java
// Domain Service에서 트랜잭션
@Service
@RequiredArgsConstructor
public class OrderCreator {

  @Transactional  // ⭐ Domain Service에서 트랜잭션
  public Order create(CreateOrderCommand command) {
    // 1. 주문번호 생성
    OrderNumber orderNumber = orderNumberGenerator.generate();

    // 2. Order 저장
    Order order = orderRepository.store(...);

    // 3. Outbox 저장 (같은 트랜잭션)
    outboxEventAppender.append(OutboxEventType.ORDER_CREATED, order);

    return order;
  }
}

// Facade는 단순 호출
@Facade
@RequiredArgsConstructor
public class OrderFacade {

  public Order createOrder(CreateOrderCommand command) {
    return orderCreator.create(command);  // 트랜잭션은 Domain Service에서
  }
}
```

---

## Command 위치

**Command는 Application이 아닌 Domain Layer에 위치합니다.**

```
❌ 잘못된 위치:
core/application/order/command/CreateOrderCommand.java

✅ 올바른 위치:
core/domain/order/command/CreateOrderCommand.java
```

**이유:**
- Command는 Domain 개념 (비즈니스 요구사항)
- Domain Service가 직접 사용
- Application은 단순히 전달만

---

## Facade vs UseCase 비교

### UseCase 패턴 (이전)

```java
@UseCase
@RequiredArgsConstructor
public class CreateOrderUseCase {
  
  private final OrderRepository orderRepository;
  private final OrderNumberGenerator orderNumberGenerator;
  private final OutboxEventPublisher outboxEventPublisher;

  @Transactional
  public Order execute(CreateOrderCommand command) {
    // UseCase에서 비즈니스 로직 직접 수행
    OrderNumber orderNumber = orderNumberGenerator.generate();
    
    Order order = Order.create(...);
    Order saved = orderRepository.save(order);
    
    outboxEventPublisher.publish(saved.getDomainEvents());
    
    return saved;
  }
}
```

**문제점:**
- ❌ UseCase가 비즈니스 로직을 직접 수행
- ❌ Domain Service 개념 없음
- ❌ 재사용 어려움

### Facade 패턴 (현재)

```java
@Facade
@RequiredArgsConstructor
public class OrderFacade {
  
  private final OrderCreator orderCreator;

  public Order createOrder(CreateOrderCommand command) {
    // Facade는 단순 호출만
    return orderCreator.create(command);
  }
}

@Service
@RequiredArgsConstructor
public class OrderCreator {
  
  @Transactional
  public Order create(CreateOrderCommand command) {
    // Domain Service가 비즈니스 로직 수행
    OrderNumber orderNumber = orderNumberGenerator.generate();
    Order order = orderRepository.store(...);
    outboxEventAppender.append(OutboxEventType.ORDER_CREATED, order);
    return order;
  }
}
```

**장점:**
- ✅ Facade는 흐름만 조정
- ✅ Domain Service가 비즈니스 로직 수행
- ✅ Domain Service 재사용 가능
- ✅ 책임 분리 명확

---

## 여러 Domain Service 조합

여러 Domain Service를 조합해야 할 때는 **Facade에서 흐름 조정**

```java
@Facade
@RequiredArgsConstructor
public class OrderFacade {
  
  private final OrderCreator orderCreator;
  private final OrderValidator orderValidator;
  private final InventoryChecker inventoryChecker;

  public Order createOrderWithValidation(CreateOrderCommand command) {
    // 1. 재고 확인 (Domain Service)
    inventoryChecker.checkAvailability(command.items());
    
    // 2. 주문 검증 (Domain Service)
    orderValidator.validate(command);
    
    // 3. 주문 생성 (Domain Service)
    return orderCreator.create(command);
  }
}
```

**특징:**
- ✅ Facade가 여러 Domain Service 조합
- ✅ 각 Domain Service는 독립적
- ✅ Facade는 흐름만 제어

---

## 복잡한 흐름 처리

### TransactionTemplate 사용 (선택적)

여러 Aggregate를 수정하고 외부 API 호출이 있는 경우

```java
@Facade
@RequiredArgsConstructor
public class OrderFacade {
  
  private final TransactionTemplate transactionTemplate;
  private final OrderCreator orderCreator;
  private final PaymentProcessor paymentProcessor;
  private final OrderStatusUpdater orderStatusUpdater;

  public Order createAndPayOrder(CreateOrderCommand command, PaymentInfo paymentInfo) {
    
    // 1. 트랜잭션 1: 주문 생성
    Order order = transactionTemplate.execute(status -> 
      orderCreator.create(command)
    );
    
    // 2. 외부 API: 결제 처리 (트랜잭션 밖)
    PaymentResult result = paymentProcessor.process(order.getId(), paymentInfo);
    
    // 3. 트랜잭션 2: 주문 상태 업데이트
    return transactionTemplate.execute(status -> 
      orderStatusUpdater.updateToPaid(order.getId(), result)
    );
  }
}
```

**언제 사용:**
- ✅ 여러 Aggregate 수정 + 외부 API 호출
- ✅ 트랜잭션 분리가 필요한 경우

---

## 예외 처리

### Domain Exception은 그대로 전파

```java
@Facade
@RequiredArgsConstructor
public class OrderFacade {
  
  private final OrderReader orderReader;

  public Order getOrderById(Long orderId) {
    // Domain Service에서 발생한 예외를 그대로 전파
    return orderReader.getOrderById(orderId);  // OrderNotFoundException 발생 가능
  }
}
```

**특징:**
- ✅ Facade는 예외를 변환하지 않음
- ✅ Domain Exception을 그대로 전파
- ✅ Controller의 ExceptionHandler에서 처리

---

## 금지 사항

### ❌ Facade에서 비즈니스 로직 직접 구현

```java
// ❌ 나쁜 예
@Facade
public class OrderFacade {
  
  public Order createOrder(CreateOrderCommand command) {
    // Facade에서 비즈니스 로직 직접 수행 금지!
    OrderNumber orderNumber = orderNumberGenerator.generate();
    Order order = Order.create(...);
    Order saved = orderRepository.store(...);
    outboxEventAppender.append(...);
    return saved;
  }
}

// ✅ 좋은 예
@Facade
public class OrderFacade {
  
  public Order createOrder(CreateOrderCommand command) {
    // Domain Service에게 위임
    return orderCreator.create(command);
  }
}
```

### ❌ Repository 직접 호출

```java
// ❌ 나쁜 예
@Facade
public class OrderFacade {
  
  private final OrderRepository orderRepository;  // 금지!

  public Order getOrder(Long id) {
    return orderRepository.findById(id).orElseThrow();
  }
}

// ✅ 좋은 예
@Facade
public class OrderFacade {
  
  private final OrderReader orderReader;  // Domain Service

  public Order getOrder(Long id) {
    return orderReader.getOrderById(id);
  }
}
```

---

## 체크리스트

- [ ] Facade에 @Facade 애노테이션이 있는가?
- [ ] Facade가 Domain Service만 호출하는가?
- [ ] Facade에 비즈니스 로직이 없는가?
- [ ] Command가 Domain Layer에 있는가?
- [ ] Repository를 직접 호출하지 않는가?
- [ ] 트랜잭션이 Domain Service에 있는가?
- [ ] 예외를 변환하지 않고 그대로 전파하는가?

---

## 중요 원칙

1. **Facade는 흐름만 조정** (비즈니스 로직 없음)
2. **Domain Service가 비즈니스 로직 수행**
3. **Command는 Domain Layer에 위치**
4. **트랜잭션은 Domain Service에서 관리**
5. **Repository는 Domain Service를 통해서만 호출**
6. **여러 Domain Service 조합 시 Facade에서 흐름 제어**
